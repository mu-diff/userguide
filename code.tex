\section{Generalities}
The authors try to keep the notations between the mathematical background and the \matlab toolbox. In particular, lots of arguments are the same in the different functions and they are here presented once for all. A manual of every function is moreover provided by simply typing in the \matlab command window 
\begin{verbatim}
help name_of_the_function
\end{verbatim}
In all what follows, and if nothing is specified, then the following arguments refer to the below ones. The indices $p$ and $q$ vary from $1$ to $\Nscat$ where $\Nscat$ is the number of obstacles.

\paragraph{Geometry:}

\begin{center}
%\rowcolors{1}{white}{gray}
\begin{tabular}{|c |c | p{10cm}|}
\hline Name & Size or Type & Content\\[0.2cm]\hline\hline
\code{N\_scat} & $[1\times 1]$ & Number of obstacles $\Nscat$.\\\hline
\code{O} & $[2\times \Nscat]$ & Matrix of the centers of the disks such that \code{O(1,p)} is the x-coordinate of the $p^{th}$ obstacle.\\\hline
\code{Op} & $[2\times 1]$ & Coordinate of the $p^{th}$ scatterer.\\\hline
\code{Oq} & $[2\times 1]$ & Coordinate of the $q^{th}$ scatterer.\\\hline
\code{a} & $[1\times \Nscat]$ & Vector of the radii of the disks such that \code{a(p)} is the radius of the $p^{th}$ scatterer.\\\hline
\code{ap} & $[1\times 1]$ & Radius of the $p^{th}$ scatterer.\\\hline
\code{aq} & $[1\times 1]$ & Radius of the $q^{th}$ scatterer.\\\hline
\end{tabular}
\end{center}

\paragraph{Parameters (wavenumbers, incident waves, fourier series,\ldots):}
\begin{center}
\begin{tabular}{|c |c | p{10cm}|}
\hline Name & Size or Type & Content\\[0.2cm]\hline\hline
\code{beta\_inc} & $[1\times 1]$ & Angle of direction of a plane wave $e^{ik (\cos(\beta)x + \sin(\beta)y)}$.\\\hline
\code{XS} & $[2\times 1]$ & Center $(x_s,y_s)$ of a point source: $x_s=$\code{XS(1)} and $y_s=$\code{XS(2)}. A point source wave is then given by $i/4\Hz(k\|\xx-\xx_s\|)$, with $\xx=(x,y)$ and $\xx_s=(x_s,y_s)$ and $\Hz$ the zeroth order Hankel function of first kind.\\\hline
\code{k} & $[1\times 1]$ & Wavenumber $k$ in the vacuum.\\\hline
\code{k\_int} & $[1\times \Nscat]$ & Wavenumber in the obstacles: $\kintp=$\code{k\_int(p)}. If \code{k\_int} is a scalar then $\kintp$ = \code{k\_int} for all $p$.\\\hline
\code{M\_modes} & $[1\times \Nscat]$ & Vector of index of truncation of the Fourier series, \ie \code{M\_modes(p)}=$\Np$\\\hline
\code{Np} & $[1\times 1]$ & Corresponds to $\Np$, the truncation index in the Fourier serie.\\\hline
\code{Nq} & $[1\times 1]$ & Corresponds to $\Nq$, the truncation index in the Fourier serie.\\\hline
\end{tabular}
\end{center}

\paragraph{Incident wave:}
\begin{center}
\begin{tabular}{|c |c | p{10cm}|}
\hline Name & Size or Type & Content\\[0.2cm]\hline\hline
\code{PlaneWave} & $[1\times 1]$ & Wavenumber in the vacuum.\\\hline
\end{tabular}
\end{center}

\paragraph{Integral operators:} they are indexed and named by the following table:
\begin{center}
\begin{tabular}{|c |c | c | p{9cm}|}
\hline Index & Letter & Operator & \mudiff abreviation \\\hline\hline
0 & - & - & Null operator \\
1 & $I$ & \code{Identity} & Identity\\
2 & $L$ & \code{SingleLayer} & Trace of the single-layer\\
3 & $M$ & \code{DoubleLayer} & Trace of the double-layer\\
4 & $N$  & \code{DnSingleLayer}& Normal derivative of the single-Layer\\
5 & $D$  & \code{DnDoubleLayer}&Normal derivative of the double-Layer\\ 
6 & $\hat{L}$  & \code{PrecondDirichlet}& Single-scattering preconditioned trace of the single-layer operator\\
7 & $\hat{D}$  & \code{PrecondNeumann}& Single-scattering preconditioned normal derivative trace of the double-layer operator\\ \hline
\end{tabular}
\end{center}


\section{Pre-Processing}

The pre-processing functions are located in the \code{PreProcessing} folder, which is divided in two parts: the construction of the obstacles in \code{Geometry}, and the computation of the right-hand side, \ie the incident waves on the obstacles, in \code{IncidentWave}.

\subsection{Creating Obstacles}

\subsubsection{Manual placement}
The disks can be created manually by simply creating the two variables \code{O} and \code{a} containing respectively the coordinates of the disks and their radii. For example, for three obstacles placed on $(-1,2)$, $(5,5)$ and $(-15,10)$ with radii $0.1$, $0.5$ and $10$:
\begin{verbatim}
O = [-1, 5, 2 ; -15, 5, 10];
a = [0.1, 0.5, 10];
\end{verbatim}

\subsubsection{Periodic placement}

Two build-in functions are available with the toolbox to create disks periodically, with a rectangular or a triangular lattice, as shown on figure \ref{??}. The two functions are called as follows, for the rectangular lattice:
\begin{verbatim}
O = RectangularLattice(bx, by, Nx, Ny);
\end{verbatim}
and for the triangular lattice:
\begin{verbatim}
O = TriangularLattice(bx,by,Nx,Ny);
\end{verbatim}
where :
\begin{itemize}
\item \code{bx} and \code{by} are the distance separating two centers in the $x$ coordinate and \code{by} the distance between two rows in the $y$-direction. The two other parameter 
\item \code{Nx}: number of disks in a row
\item \code{Ny}: number of rows
\end{itemize}
For both functions, the vector of radii must be built separately. If the disks are unitary then the following command can be used
\begin{verbatim}
a = ones(size(O,2));
\end{verbatim}


\subsubsection{Random placement}

Finally, to place randomly obstacles in a box $[\code{xmin}, \code{xmax}]\times[\code{ymin},\code{ymax}]$ with also a random radius, a function \code{CreateRandomDisks} is very helpful. In its simplest version, the function is called as:
\begin{verbatim}
[O, a] = CreateRandomDisks(xmin, xmax, ymin, ymax, N_scat);
\end{verbatim}
The function will then create \code{N\_scat} disk with unit radius in the desired box. This is however probably too simple and the function can be called in a more complex form:
\begin{verbatim}
[O, a] = CreateRandomDisks(xmin, xmax, ymin, ymax, N_scat, 
           amin, amax, dmim, dmax, O_avoid, a_avoid, dmin_avoid, dmax_avoid);
\end{verbatim}
where
\begin{center}
\begin{tabular}{|c |c|c | p{10cm}|}
\hline Variable & Type & Default & Action\\\hline
\code{amin} & scalar  & 1 & Minimal (random) radius of the obstacles allowed \\\hline
\code{amax} & scalar  & 1 & Maximal (random) radius of the obstacles  allowed\\\hline
\code{dmin} & scalar & \code{realmin} & Minimal distance allowed between two obstacle (not between the centers!). Setting $\leq 0$  value will set \code{dmin} to \code{realmin} (\ie ignore it)\\\hline
\code{dmax} & scalar & \code{realmax} & Maximal distance allowed between two obstacle (not between the centers!). The maximal distance is quickly reached! Setting $\leq 0$  value will set \code{dmax} to \code{realmax} (\ie ignore it).\\\hline
\code{O\_avoid} & \code{[2 x N]} & \code{[]} & Center of \code{N} hole(s) where the obstacles must not overlap. Usefull for example for point source location.\\\hline
\code{a\_avoid} & \code{[1 x N]} & \code{[]} & Radii of the \code{N} holes\\\hline
\code{dmin\_avoid} & \code{[1 x N]} & \code{[]} & Minimal distance between an obstacle and a hole\\\hline
\end{tabular}
\end{center}
These optional arguments are not mandatory in the function call. For example:
\begin{verbatim}
[O, a] = CreateRandomDisks(xmin, xmax, ymin, ymax, N_scat, amin, amax);
\end{verbatim}
will create random disks with random radii without taking into account the distances between the disks (except obviously the overlapping).

For example, building 7 obstacles in the box $[-10,10]\times[-10,10]$ with radii between $0.1$ and $0.5$. The disks must be separated at minimum by a distance of $0.1$ and without maximum value. The command is then:
\begin{verbatim}
[O, a] = CreateRandomDisks(-10, 10, -10, 10, 7, 0.1, 0.5, 0.1, -1);
\end{verbatim}
Now imagine that a point source is located on $(2,2)$ and that the obstacles must be separated from the source from at least $0.3$, then the ``\code{*\_avoid}'' arguments can be used and command can be
\begin{verbatim}
[O, a] = CreateRandomDisks(-10, 10, -10, 10, 7, 0.1, 0.5, 0.1, -1, [2;2], 0.3);
\end{verbatim}
the disk centered on $(2,2)$ with radius $0.3$ will then be avoided. A second option is to set \code{a\_void} to zero and set the minimal distance \code{dmin\_avoid} to $0.3$:
\begin{verbatim}
[O, a] = CreateRandomDisks(-10, 10, -10, 10, 7, 0.1, 0.5, 0.1, -1, [2;2], 0, 0.3);
\end{verbatim}


\begin{remark}
To verify if a disk is well placed, \code{CreateRandomDisks} calls \code{CheckPlacement} function, which can also be useful for a user placing obstacles.
\end{remark}

\subsubsection{Removing disks}

The function \code{RemoveDisk} aims to remove some disks of the geometrical configuration, either disk by disk, by row or by column or by radius. Here is its syntax
\begin{verbatim}
[O,a] = RemoveDisk(O_old, a_old, ...);
\end{verbatim}
where \code{O\_old} and \code{a\_old} are the centers and radii of the current geometry. Without optional argument, the function will return \code{[O\_old, a\_old]} and the available arguments are:
\begin{itemize}
\item \code{[O,a] = RemoveDisk(..., 'X', [X1, X2, ..., XN]);}\\
Remove all the points with X abscissa X1, X2, ..., or XN
\item \code{[O,a] = RemoveDisk(...,  'Y', [Y1, Y2, ..., YN]);}\\
Remove all the points with Y ordinate Y1, Y2, ..., or YN
\item \code{[O,a] = RemoveDisk(..., 'XY', [[X1;Y1], [X2;Y2], ..., [XN;YN]]);}\\
Remove all the points [X1;Y1], [X2;Y2], ..., and [XN;YN]
\item \code{[O,a] = RemoveDisk(..., 'Radius', [a1, a2, ..., aN]);}\\
Remove all the disk with radius a1, a2, ..., or aN
\item \code{[O,a] = RemoveDisk(..., 'Verbosity', VERBOSITY);}\\
set VERBOSITY to 0 to avoid display message, to 1 to only show results, and to $>1$ to see everything (default).
\item \code{[O,a] = RemoveDisk(..., 'Tol', TOL);}\\
Tolerance used for the conditional statement (default $10^{-10}$).
\end{itemize}

For example, to remove every obstacle on the row of $x-$abscissa $1$ and $y-$ordinate $2.5$:
\begin{verbatim}
[O,a] = RemoveDisk(O\_old, a\_old, 'X', 1, 'Y', 2.5);
\end{verbatim}
Or, to remove the obstacles centered on $(2,5)$ and (3,4):
\begin{verbatim}
[O,a] = RemoveDisk(O\_old, a\_old, 'XY', [2,3;5,4]);
\end{verbatim}

\subsection{Incident waves}

Two different incident waves, plane wave and point source wave, are available in the \mudiff toolbox, but it should be highlighted that the user can build his/her own incident wave. A right-hand side $b$ is decomposed by blocks, each of these representing one obstacle: $b= (b_p)_{p=1,\ldots,\Nscat}$. As a different condition can be applied on an obstacle or a different integral equation can be considered on it, each block can be specified separately. Depending on the type of desired right-hand side, the block function \code{BlockIncidentWave} will compute the vector $b_p$. The frontal function \code{IncidentWave}, which compute the whole vector $b$, consists on calling  \code{BlockIncidentWave} for each obstacle and assembling the vector. Interfaced functions are available to compute directly some incident wave, such as \code{PlaneWave}, \code{PointSource} or \code{DnPlaneWave} and \code{DnPointSource}. They call \code{IncidentWave} with the right argument. There is no need here to described these functions, however their help is helpful and contains the mathematical description of the incident wave.

\subsubsection{\code{BlockIncidentWave}}

This functions computes the block vector of \textbf{the opposite of} the coefficients of an incident wave, either the trace of the normal derivative trace, on one of the obstacles, in the Fourier bases. Its syntax is
\begin{verbatim}
Bp = BlockIncidentWave(Op, ap, Np, k, TypeOfWave, Param);
\end{verbatim}
where \code{TypeOfWave} is a scalar value specifying the incident wave (see below) and \code{Param} is the parameter of the wave, that is the angle of direction or the position of a point source. The returned value \code{Bp} is a column vector of length 2\code{Np}+1. Below is listed the possible value of \code{TypeOfWave}, the interface function name, the associated parameter and the resulting wave:
\begin{center}
\begin{tabular}{|c| c |c| p{9cm}| }
\hline Value & \mudiff name & Param & Type\\\hline
1 & \code{PlaneWave} & \code{beta\_inc} & Trace of a plane wave of angle of direction \code{beta\_inc}. A plane wave is defined by $e^{ik(\cos(\beta)x + \sin(\beta)y}$.\\\hline
2 & \code{DnPlaneWave} & \code{beta\_inc} & Normal derivative of a plane wave of angle of direction \code{beta\_inc}.\\\hline
3 & \code{PointSource} & \code{XS} & Trace of the wave emitted by a point source placed on \code{XS}. Such a wave is defined in \mudiff by $i/4\Hz(k\|\xx-\xx_s\|)$.\\\hline
4 & \code{DnPointSource} & \code{XS} & Normal derivative of the trace of the wave emitted by a point source placed on \code{XS}.\\\hline
5 & \code{PlaneWavePrecond} & \code{beta\_inc} & Same as \code{PlaneWave} but multiplied by the inverse diagonal of the single-layer diagonal block operator (see section \ref{} on single scattering preconditioner). \\\hline
6 & \code{DnPlaneWavePrecond} & \code{beta\_inc} & Same as \code{DnPlaneWave} but multiplied by the inverse diagonal of the double-layer diagonal block operator. \\\hline
\end{tabular}\end{center}

\subsubsection{\code{IncidentWave}}

\begin{verbatim}
B = IncidentWave(O, a, M_modes, k, TypeOfWave, Param)
\end{verbatim}
The resulting vector \code{B} is of size $\sum_{p=1}^{\Nscat}(2\code{M\_modes}(p)+1)$. The value \code{Param} is the same as for \code{BlockIncidentWave} whereas \code{TypeOfWave} is a vector of size $\Nscat$ where \code{TypeOfWave}(p) is the desired choice for the block $b_p$. In other word, the block $b_p$ will be built by calling \code{BlockIncidentWave(Op, ap, Np, k, TypeOfWave, Param);}. To simplify, if \code{TypeOfWave} is a scalar value, then it is considered as a vector of the same scalar value.

For example, building a vector associated to the trace of an incident plane wave of direction \code{beta\_inc} is done thanks to the following command:
\begin{verbatim}
B = IncidentWave(O, a, M_modes, k,  1, beta\_inc);
\end{verbatim}
For two obstacles and a point source centered on $(1,2)$, if $b_1$ is the trace of the wave and $b_2$ is the normal derivative trace, then
\begin{verbatim}
B = IncidentWave(O, a, M_modes, k,  [3;4],[1;2]);
\end{verbatim}

\begin{remark}
Remember that the resulting vector corresponds to the opposite of the trace or normal derivative trace!
\end{remark}


\section{Integral operators}

Two different type of storage are provided with the \mudiff toolbox: dense and sparse. The dense version store the whole matrix in memory whereas the sparse version uses the special structure of the matrix of an integral operator to store it. The sparse storage in \mudiff and this user guide has nothing to deal with the sparse storage provided in \matlab such as \texttt{sparse} function. The dense storage is easier to use and works pretty well for small scale problems. It also presents the advantage of providing the whole matrix of the integral operator, which can be useful for spectrum analysis for example. On the other hand, for a large number of circular obstacles and/or for large frequency, the memory storage becomes too important and the sparse version must be used. One should be however careful: the sparse matrix-vector product, based on the cross-correlation (\texttt{xcorr} \matlab function), is very sensitive to the number of modes chosen in the truncation of the Fourier series. Indeed, if too many modes are kept, the matrix-vector product show to be unstable. The formula (\ref{??}) seems to provide stability.

To explain how the code works, let us take an example of one of the four boundary integral operator $L,M,N$ or $D$ being discretized as a generic matrix $\Ab = (\Abpq)_{1\leq p,q\leq \Nscat}$. Let us highlight that \mudiff can manage more complexe matrices, where two different blocks are not the discretization of the same operators or can even be a linear combination of operators. Nevertheless, if $\Ap$ is one of the four boundary integral operators, then as highlighted in previous chapter, $\Ab$ has the following structure, for $p,q=1,\ldots,\Nscat$ and $p\neq q$:
\begin{itemize}
\item $\Abpp$ is diagonal.
\item $\Abpq$ is full and can be divided as $\Abpq = \AbpqL\Tbpq\AbpqR$ where $\AbpqL$ and $\AbpqR$ are diagonal and called respectively the left and right part, and $\Tbpq = (\Tbpqmn))$, with $\Tbpqmn = i\pi e^{??}H_0^{(1)}(k\bpq)$, is a Toeplitz matrix.
\end{itemize}
In the sparse version, diagonal submatrices $\Abpp,\AbpqL$ and $\AbpqR$  are stored as a vector of size respectively $2\Np+1$, $2\Np+1$ and $2\Nq+1$, and the Toeplitz matrices $\Tbpq$ are stored as vectors of size $2\Np+2\Nq-1$.

This section is naturally divided in two part, the first being devoted to the dense storage and the second to the sparse version. The assembly, the storage and the usage of the matrices being significantly different.

\subsection{Available integral operators and numbering}
\label{seccode:IntOp}

\mudiff can build the four boundary integral operators $L,M,N$ and $D$ described in the previous chapter, and also the single-scattering version of the EFIE, that is $??$ (Dirichlet) and $??$ (Neumann). As for the incident wave, in \mudiff, a unique number is assigned to every operator.

\begin{center}\begin{tabular}{|c| c| c|c|}
\hline Int. Op. & Number & \mudiff Name & Value for $\xx\in\Gamma$\\\hline
- & 0 & \code{Zero} & Zero operator (null matrix)\\\hline
$I$ & 1 & \code{Identity} & Identity\\\hline
$L$ & 2 & \code{SingleLayer} & $\dsp L\rho(\xx) = \int_{\Gamma} G(\xx,\yy) \rho(\yy)\dd\yy$\\\hline
$M$ & 3 & \code{DoubleLayer} & $\dsp M\lambda(\xx) = -\int_{\Gamma} \dny G(\xx,\yy) \lambda(\yy)\dd\yy$\\\hline
$N$ & 4 & \code{DnSingleLayer} & $\dsp N\rho(\xx) = \dnx\int_{\Gamma} G(\xx,\yy) \rho(\yy)\dd\yy$\\\hline
$D$ & 5 & \code{DnDoubleLayer} & $\dsp D\lambda(\xx) = -\dnx\int_{\Gamma} \dny G(\xx,\yy) \lambda(\yy)\dd\yy$\\\hline
$\hat{L}L$ & 6 & \code{PrecondDirichlet} & Single-Layer preconditioned by its diagonal\\\hline
$\hat{D}D$& 7 & \code{PrecondNeumann} & Dn Double-Layer preconditioned by its diagonal\\\hline
\end{tabular}\end{center}

\subsection{Dense storage}
\subsubsection{Building a block $\Abpq$}

A block is created thanks to \texttt{BlockIntegralOperator} function, which has the following syntax
\begin{verbatim}
	Apq = BlockIntegralOperator(Op, ap, Np, Oq, aq, Nq, k, TypeOfOperator, Weight);
\end{verbatim}
The \code{Weight} argument is optional and set to $1$ by default. The quantity \code{TypeOfOperator} specifies the integral operator to compute, thanks to the numbering of section \ref{seccode:IntOp}. If \code{TypeOfOperator} is a scalar (\eg $=2$) then the resulting matrix \code{Apq} is the submatrix of the associated operator (\eg $\Lbpq$). If \code{TypeOfOperator} is a row (\eg \code{[1,3]}) then the sum of the two operators is done (\eg $\Ibpq+\Mbpq$). Finally the \code{Weight} quantity, of the same size as \code{TypeOfOperator}, is the constant to multiply the block with.

An example being more precise than a huge speak, let us build some blocks:
\begin{itemize}
\item The single-layer block $\Lbpq$:
\begin{verbatim}
Apq = BlockIntegralOperator(Op, ap, Np, Oq, aq, Nq, k, 1);
\end{verbatim}
\item The block $0.5\Ibpq + \Mbpq$, appearing in the MFIE (\ref{??}):
\begin{verbatim}
Apq = BlockIntegralOperator(Op, ap, Np, Oq, aq, Nq, k, [1, 3], [0.5, 1]);
\end{verbatim}
\item The sum of the four integral operator $0.5\Lbpq + 1.5\Mbpq + 2.5\Nbpq + 3.5\Dbpq$:
\begin{verbatim}
Apq = BlockIntegralOperator(Op, ap, Np, Oq, aq, Nq, k, [2, 3, 4, 5], 
[0.5, 1.5, 2.5, 3.5]);
\end{verbatim}
\end{itemize}

\subsubsection{Assemble the matrix $\Ab$}

Now that the construction of a block is well understood, building a matrix is very easy thanks to the frontal function
\begin{verbatim}
A = IntegralOperator(O, a, M_modes, k, TypeOfOperator, Weight);
\end{verbatim}
As for \code{BlockIntegralOperator}, the quantity \code{Weight} is optional and set to $1$ by default. Roughly speaking, \code{IntegralOperator} will loop on every obstacle $p$ and $q$ and launch the following command
\begin{verbatim}
Apq = BlockIntegralOperator(Op, ap, Np, Oq, aq, Nq, k, Tpq, Wpq);
\end{verbatim}
where \code{Tpq} and \code{Wpq} are given by \code{TypeOfOperator} and \code{Weight} such that (\code{Weight} is of the same size of \code{TypeOfOperator} and so \code{Wpq} follows the same rules as \code{Tpq}):
\begin{itemize}
\item If \code{TypeOfOperator} is a scalar then \code{Tpq} = \code{TypeOfOperator}. 
\item If \code{TypeOfOperator} is a row or a column vector then \code{Tpq} is an array given by \code{Tpq} = \code{TypeOfOperator}. 
\item If \code{TypeOfOperator} is a matrix then \code{Tpq} = \code{TypeOfOperator(p,q)}. 
\item If \code{TypeOfOperator} is a $3D-$array then \code{Tpq} is an array and is given by \code{Tpq(:)} = \code{TypeOfOperator(p,q,:)}. 
\end{itemize}

For example, building \ldots 
\begin{itemize}
\item The single-layer potential $L$
\begin{verbatim}
L = IntegralOperator(O, a, M_modes, k, 2);
\end{verbatim}
\item The operator of the MFIE for a Dirichlet boundary condition (\ref{??}), $0.5I + N$:
\begin{verbatim}
A_MFIE = IntegralOperator(O, a, M_modes, k, [1,4], [0.5,1]);
\end{verbatim}
\item The following operator
$$
\left(\begin{array}{c c}
0.5 I_{1,1}+ M_{1,1} & L_{1,2}\\
D_{2,1} & 0.5 I_{2,2}+N_{2,2}
\end{array}\right)
$$
can be done using also the null operator:
\begin{verbatim}
TypeOfOp = zeros(2,2,2); Weight = zeros(2,2,2);
TypeOfOp(1,1, :) = [1, 3]; Weight(1,1, :) = [0.5, 1]; %block A_{1,1}
TypeOfOp(1,2, :) = [2, 0]; Weight(1,2, :) = [1, 0]; %block A_{1,2}
TypeOfOp(2,1, :) = [5, 0]; Weight(2,1, :) = [1, 0]; %block A_{2,1}
TypeOfOp(2,2, :) = [1, 4]; Weight(2,2, :) = [0.5, 1]; %block A_{2,2}
A = IntegralOperator(O, a, M_modes, k, TypeOfOp, Weight);
\end{verbatim}
\end{itemize}

\subsection{Sparse storage}

Storing the matrices in a sparse way lead to a significant reduction in memory storage and a faster matrix-vector product. The linear system must then however be solved using an iterative solver only, as the matrix is no more fully stored. Combining linearly the matrices is still possible but is done during the matrix-vector product, indeed, summing two matrices of two different integral operators is not guaranteed to keep the special structure. If the problem involves (at least) two different integral operators, they must hence be computed separately.

\subsubsection{Storage: generalities}

To explain how the matrix is stored using \mudiff sparse storage, let $\Ab$ be the matrix of one of the four integral operators $L,M,N$ or $D$. The matrix $\Ab$ has the following special structure
\begin{itemize}
\item $\Abpp$ is diagonal
\item $\Abpq$ is full and can be divided as $\Abpq = \AbpqL\Tbpq\AbpqR$ where $\AbpqL$ and $\AbpqR$ are diagonal and called respectively the left and right part, and $\Tbpq = (\Tbpqmn))$, with $\Tbpqmn = i\pi e^{??}H_0^{(1)}(k\bpq)$, is a Toeplitz matrix.
\end{itemize}

Let $\AbL$ and $\AbR$ be two $3D$ arrays such that
$$
\AbL(:,p,q) = \begin{cases}
\diag(\Abpp) & \text{ if }p=q,\\
\AbpqL & \text{ otherwise,}
\end{cases}\qquad
\AbR(:,p,q) = \begin{cases}
0 & \text{ if }p=q,\\
\AbpqR & \text{ otherwise.}
\end{cases}
$$
There is only $\Tbpq$, of size $(2\Np+1) \times (2\Nq+1)$ to be stored sparsely. A Toeplitz matrix has the following structure
$$
\Tbpq = \left(\begin{array}{c c c c c}
t_1 & t_2 & t_3 & \ldots & t_{(2\Nq+1)} \\
t_{(2\Nq+1)+1} & t_{1} & t_{2} & \ldots & t_{(2\Nq+1)-1}\\
t_{(2\Nq+1)+2} & t_{(2\Nq+1)+1} & t_{1} & \ldots & t_{(2\Nq+1)-2}\\
\vdots & \ddots & \ddots& \ddots& \vdots\\
%t_{(2\Nq+1)+(2\Np+1)-2} & t_{(2\Nq+1)+(2\Np+1)-3} & t_{(2\Nq+1)+(2\Np+1)-4} &   \ldots & t_{(2\Np+1)+1}\\
t_{(2\Nq+1)+(2\Np+1)-1} & t_{(2\Nq+1)+(2\Np+1)-2} & t_{(2\Nq+1)+(2\Np+1)-3} &   \ldots  & t_{(2\Nq+1)-(2\Np+1)+1}
\end{array}\right)
$$
Clearly, only the first row and the first column are necessary to build the matrix and hence $\Tbpq$ can be stored as a root vector $\AbpqM$ of size $(2\Np+1)+ (2\Nq+1)-1 = 2\Np +2\Nq+1$ and such that:
$$
\AbpqM = \left(\begin{array}{c}
t_{(2\Nq+1)+(2\Np+1)-1}\\
t_{(2\Nq+1)+(2\Np+1)-2}\\
\vdots\\
t_{(2\Nq+1)+2}\\
t_{(2\Nq+1)+1}\\
t_{1}\\
t_{2}\\
t_{3} \\
\vdots\\
t_{(2\Nq+1), 1}\\
\end{array}\right).
$$
Finally, the $3D$ array $\AbM$ will store every sub-vectors $\AbpqM$:
$$
\AbM(:,p,q) = \begin{cases}
0 & \text{ if }p=q,\\
\AbpqM & \text{ otherwise.}
\end{cases}
$$

The whole matrix $\Ab$ is thus stored in three different part: $\AbL$, $\AbM$ and $\AbR$. In the computer point of view, as a $3D$ array has a fix size in each direction, hence, in Matlab, the sizes of the arrays are given by
\begin{center}
\begin{tabular}{| l | l |}
\hline$\AbL$ & $\dsp \max_p(2\Np+1)$\\[0.2cm]\hline
$\AbM$ & $\dsp \max_{p}\max_{q\neq p}\left[(2\Np+1)+(2\Nq+1)-1\right]$\\[0.2cm]\hline
$\AbR$ & $\dsp \max_p(2\Np+1)$\\[0.2cm]\hline
\end{tabular}\end{center}
With this constraint, the vector $\AbL(:,p,q)$ can be larger than $2\Np+1$ and thus $\AbpqL$ must be extracted: $\AbpqL = \AbL(1:2\Np+1,p)$. The same occurs for $\AbM$ and $\AbR$. 

Finally, these $3D$ arrays are merged into a cell \code{A}, representing the matrix $\Ab$, such that, using the Matlab notations:
$$
\code{A}\{1\} = \AbL,\qquad \code{A}\{2\} = \AbM,\qquad\code{A}\{3\} = \AbR.
$$

\subsubsection{Matrix-vector product}

The matrix vector product between \code{A} and a vector $X$ is divided in different parts. Let us look at $Y=\Ab X$ and more particularly at the $p^{th}$ component
$$
Y_p = \sum_{q} \Abpq X_q.
$$
Using the previous notations, it comes that
$$
Y_p = \AbppL X_p + \sum_{q\neq p} \AbpqL (\AbpqM (\AbpqR X_q)).
$$
As $\AbppL$, $\AbpqL$ and $\AbpqR$ are all diagonal (and stored as a vector), these matrix-vector products are easy to compute. The only difficulty is located in $\AbpqM Z_q$ (where $Z_q=\AbpqR X_q$), but it can be achieved in a fast way. Indeed, the discrete cross correlation product (\code{xcorr}) between $\AbpqM$ and $Z_q$ gives
$$
\widetilde{W}_q = \code{xcorr}(Z_q, \overline{\AbpqM}),
$$
where the over bar denotes a complex conjugation. And the result $W_q$ is then extracted from $\widetilde{W}_q$ by
$$
W_q = \widetilde{W}_q(2\Nq+1:2\Nq+1+2\Np).
$$
The matrix vector product between $\Ab$ and $X$ is then done in a fast way (cross correlation is fast using Fourier).


\subsubsection{Assembly: Matlab functions}

The assembly process is very similar to the dense one, the difference being the prefix \code{Sp}. The block function is then called by
\begin{verbatim}
SpBlockIntegralOperator(Op, ap, Np, Oq, aq, Nq, Nmax, k, TypeOfOperator, Weight);
\end{verbatim}
The major difference here is that \textbf{no linear combination of operators can be done during the assembly process} for the sparse representation. The quantity \code{TypeOfOperator} cannot hence be a vector but only a scalar. On the other hand, the full assembly of a matrix can be done through
\begin{verbatim}
A = SpIntegralOperator(O, a, M_modes, k, TypeOfOperator, Weight);
\end{verbatim}
where \code{TypeOfOperator} can be a scalar or a matrix (not a $3D$ array nor a vector!). If \code{TypeOfOperator} is a matrix, then the block $\Abpq$ is assumed to be of type \code{TypeOfOperator(p,q)}. The linear combination of operators can still be done, but must be specified in the matrix-vector product (see below). Note that a function exists to add the (weighted-)identity to a sparse operator (see below).

Here is an example of the creation of \mudiff sparse matrix of the single-layer operator $L$
\begin{verbatim}
L = SpIntegralOperator(O, a, M_modes, k, 2);
\end{verbatim}

\subsubsection{Assembly: adding the identity}

It is possible to add the identity multiplied by a constant to a sparse operator, thanks to
\begin{verbatim}
A = SpAddIdentity(A, alpha, M_modes);
\end{verbatim}
which simply returns $A = A+\alpha I$.

\subsubsection{Linear combination of operator}

A matrix vector product $Y = \Ab X$ is done thanks to 
\begin{verbatim}
Y = SpMatVec(X, M_modes, ListOfOperators, Weight);
\end{verbatim}
where \code{Weight} is optional. \code{ListOfOperators} is a \textbf{Matlab cell} (not an array!) containing every sparse matrix that the user want to multiply. For example, computing $\Lb X$ is done as follows:
\begin{verbatim}
SpL = SpIntegralOperator(O, a, M_modes, k, 2);
Y = SpMatVec(X, M_modes, SpL);
\end{verbatim}
And computing $Y =(0.5*I + N)X$, where $I$ is the identity (\textbf{Beware the $\{\cdot\}$ !}):
\begin{verbatim}
[SpN{1}, SpN{2}, SpN{3}] = SpDnSingleLayer(O, a, M_modes, k);
[I{1},I{2},I{3}] = SpIdentity(O, a, M_modes);
Y = SpMatVec(X, M_modes, {I,A}, [0.5, 1]);
\end{verbatim}
This could also be done using \code{SpAddIdentity} function:
\begin{verbatim}
[SpN{1}, SpN{2}, SpN{3}] = SpDnSingleLayer(O, a, M_modes, k);
[A{1},A{2},A{3}] = SpAddIdentity(SpN, 0.5, M_modes);
Y = SpMatVec(X, M_modes, A);
\end{verbatim}

\subsubsection{Solving a linear system}

Now that the matrices and the right hand side have been assembled, the sparse linear system can solved iteratively. Using for example the GMRES solver \cite{??}, the syntax to solve the EFIE (\ref{??}) would be
\begin{verbatim}
SpL = SpIntegralOperator(O, a, M_modes, k, 2);
Uinc = PlaneWave(O, a, M_modes, k, beta_inc);
rho = gmres(@(X)SpMatVec(X, M_modes, SpL), Uinc);
\end{verbatim}
Solving the MFIE (\ref{}) can be done as
\begin{verbatim}
[SpN{1}, SpN{2}, SpN{3}] = SpDnSingleLayer(O, a, M_modes, k);
[I{1},I{2},I{3}] = SpIdentity(O, a, M_modes);
DnUinc = DnPlaneWave(O, a, M_modes, k, beta_inc);
lambda = gmres(@(X)SpMatVec(X, M_modes,{I,SpN}, [0.5,1]), DnUinc);
\end{verbatim}
or using the \code{SpAddIdentity} function
\begin{verbatim}
[SpAMFIE{1}, SpAMFIE{2}, SpAMFIE{3}] = SpDnSingleLayer(O, a, M_modes, k);
[SpAMFIE{1}, SpAMFIE{2}, SpAMFIE{3}] = SpAddIdentity(SpAMFIE, 0.5, M_modes);
DnUinc = DnPlaneWave(O, a, M_modes, k, beta_inc);
lambda = gmres(@(X)SpMatVec(X, M_modes, SpAMFIE, ), DnUinc);
\end{verbatim}


\section{Post-Processing}

Now that the system has been solved, the next step is to display the results. The \mudiff toolbox proposes some post-processing features such as computing the far-field (fast) or the near-field (more time consuming) of the wave on a grid (Matlab \code{mesh grid}) or on some points only. In addition, other features are available to draw the disks or the incident field. Both the near- and far-field computations can be done for a linear combination of a single- and double-layer potentials $\Lop\rho + \Mop\lambda$, only one of them (\eg $\Lop\rho$) or with the same density $(\Lop+\Mop)\psi$, with a single command line.

\subsubsection{Far field}

The far field of a potential $\eta\Lop\rho + \gamma\Mop\lambda$, given by formul\ae{} (\ref{??}) and (\ref{??}), is computed thanks to the \code{FarField} function:
\begin{verbatim}
F = FarField(O, a, M_modes, k, theta, Density, Weight);
\end{verbatim}
where \code{theta} is the vector of receiving angles (in rad.), \code{Density} is either $\rho$, $\lambda$ or both and \code{Weight} is the weights to apply to the volumic integral operators. To be more precise, the potential is assumed to be of the form
$$
\code{Weight(1)}\Lop\code{Density(:,1)} + \code{Weight(2)}\Mop\code{Density(:,2)}.
$$
Note that if \code{Density} is a column vector then \code{Density(:,2)} = \code{Density(:,1)} (the same density is used for both single- and double-layer potentials. Here is the example of the EFIE for the Dirichlet problem, where the scattered field $u$ reads as $u = \Lop\rho$, its far field is then computed by
\begin{verbatim}
F = FarField(O, a, M_modes, k, theta, rho, [1,0]);
\end{verbatim}
For the Brackage-Werner integral equation for the Dirichlet problem,  the scattered field $u$ reads as $u = (-\eta\Lop-\Mop)\psi$, and its far field is computed by
\begin{verbatim}
F = FarField(O, a, M_modes, k, theta, psi, [-eta,-1]);
\end{verbatim}

\subsubsection{Radar Cross Section (RCS)}

The radar cross section of a far field can be computed either from the far field with \code{FarField\_to\_RCS} or directly from the density with \code{RCS}. In \mudiff, the radar cross section $\sigma$ is obtained by ($F$ being the far field)
$$
\sigma = 10\log_{10}(2\pi|F|^2).
$$
The syntax is then simply
\begin{verbatim}
R = FarField_to_RCS(F);
\end{verbatim}
where \code{F} has been computed by the \code{FarField} function. Otherwise, the RSC can be computed directly from the densities by
\begin{verbatim}
R = RCS(O, a, M_modes, k, theta, Density, Weight);
\end{verbatim}
where the arguments are exactly the same as for the far field. In fact, \code{RCS} first calls \code{FarField} and the \code{FarField\_to\_RCS}.

\subsubsection{Near field}

The near field of a potential is given by equations (\ref{??}) and (\ref{??}) outside the obstacles and by (\ref{??}) and (\ref{??}) inside. In the same way, \mudiff separates the outside and the inside computation.

\paragraph{Outside the obstacles}

\subsubsection{Incident wave}

\subsubsection{Obstacles}

\section{Full Examples}

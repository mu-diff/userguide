\section{Generalities}
An effort has been made to keep the same notations between the mathematical background and the \mudiff toolbox. A manual of every function is moreover provided by typing the classical \matlab command window 
\begin{verbatim}
help name_of_the_function;
\end{verbatim}

Because \mudiff includes all the integral operators that are needed in scattering (traces and normal derivative
traces of the single- and double-layer potentials), a large class of scattering problems can be solved. 
Concerning the geometrical configurations, any deterministic or random distribution of disks is possible. Finally,
\mudiff includes post-processing facilities like \eg: surface and far-fields computations, total and scattered exterior (near-field)
visualization\ldots

We now introduce the \mudiff  toolbox for Matlab by explaining the main predefined functions and their relations
with the previous mathematical derivations.
Section \ref{sectionPreProcessing}  shows how to define the scattering configuration (geometry and physical parameters). Section
 \ref{ResolutionMuDiff}  presents the way the integral equations must be defined and solved.
  Finally, section \ref{sectionPostProcessing} describes the data post-processing. 

The \mudiff toolbox  is organized following the five subdirectories:
\begin{itemize}
\item \texttt{mudiff/PreProcessing/}: pre-processing data functions (incident wave and geometry) (section \ref{sectionPreProcessing}).
\item \texttt{mudiff/IntOperators/}: functions for the four basic integral operators (dense and sparse structure)
used in the definition of the integral equations to solve (section \ref{ResolutionMuDiff}). 
\item \texttt{mudiff/PostProcessing/}: post-processing functions of the solution (trace and normal derivative traces,
computation of the scattered/total wavefield 
at some points of the spatial domain or on a grid, far-field and RCS) 
(section \ref{sectionPostProcessing}).
\item \texttt{mudiff/Common/}: this directory includes functions that are used in \mudiff but which does not need to be known
from the standard user point of view.
\item \texttt{mudiff/Examples/}: various scripts are presented for the user in standard configurations.
\end{itemize}
In addition, the \mudiff user-guide, licence and credits can be found under the directory \texttt{mudiff/Doc/}.

\section{Common argument and notations}

A large number of arguments of the \mudiff functions are the same. For the sake of conciseness and if nothing is specified, the following arguments refer to the below ones, where the indices $p$ and $q$ vary from $1$ to $M$ (or \code{N\_scat} in the \mudiff language). In addition, every function or value specific to \mudiff are written with this \code{font}. 

\paragraph{Geometry:}

\begin{center}
%\rowcolors{1}{white}{gray}
\begin{tabular}{|c |c | p{10cm}|}
\hline Name & Size & Content\\[0.2cm]\hline\hline
\code{N\_scat} & $[1\times 1]$ & Number of obstacles $M$.\\\hline
\code{O} & $[2\times \Nscat]$ & Matrix of the centers of the disks such that \code{O(1,p)} (resp. \code{O(2,p)}) is the $x-$coordinate (resp. $y-$coordinate) of the $p^{th}$ obstacle.\\\hline
\code{Op} & $[2\times 1]$ & Coordinates of the $p^{th}$ scatterer.\\\hline
\code{Oq} & $[2\times 1]$ & Coordinates of the $q^{th}$ scatterer.\\\hline
\code{a} & $[1\times \Nscat]$ & Vector of the radii of the disks such that \code{a(p)} is the radius of the $p^{th}$ scatterer.\\\hline
\code{ap} & $[1\times 1]$ & Radius of the $p^{th}$ scatterer.\\\hline
\code{aq} & $[1\times 1]$ & Radius of the $q^{th}$ scatterer.\\\hline
\end{tabular}
\end{center}

\paragraph{Parameters (wavenumbers, incident waves, fourier series,\ldots):}
\begin{center}
\begin{tabular}{|c |c | p{10cm}|}
\hline Name & Size & Content\\[0.2cm]\hline\hline
\code{beta\_inc} & $[1\times 1]$ & Angle of direction $\beta$ of a plane wave $e^{ik (\cos(\beta)x + \sin(\beta)y)}$.\\\hline
\code{XS} & $[2\times 1]$ & Center $(x_s,y_s)$ of a point source: $x_s=$\code{XS(1)} and $y_s=$\code{XS(2)}. A point source wave is given by $i/4\Hz(k\|\xx-\xx_s\|)$, with $\xx=(x,y)$ and $\xx_s=(x_s,y_s)$ and $\Hz$ the zeroth order Hankel function of first kind.\\\hline
\code{k} & $[1\times 1]$ & Wavenumber $k$ in the vacuum.\\\hline
\code{k\_int} & $[1\times \Nscat]$ & Wavenumbers in the obstacles: $\kintp=$\code{k\_int(p)}. If \code{k\_int} is a scalar then $\kintp$ = \code{k\_int} for all $p$.\\\hline
\code{M\_modes} & $[1\times \Nscat]$ & Vector of index of truncation of the Fourier series, \ie \code{M\_modes(p)}=$\Np$\\\hline
\code{Np} & $[1\times 1]$ & Corresponds to $\Np$, the truncation index in the Fourier serie.\\\hline
\code{Nq} & $[1\times 1]$ & Corresponds to $\Nq$, the truncation index in the Fourier serie.\\\hline
\end{tabular}
\end{center}

\paragraph{Integral operators:} as explained in Section \ref{??}, they are indexed and named by the following table:
\begin{center}
\begin{tabular}{|c |c | c | p{9cm}|}
\hline Index & Letter & \mudiff abreviation & Operator \\\hline\hline
0 & - & - & Null operator \\\hline
1 & $I$ & \code{Identity} & Identity\\\hline
2 & $L$ & \code{SingleLayer} & $\dsp L\rho = \int_{\Gamma}G(\xx,\yy)\rho(\yy)\;\dd\yy$\\\hline
3 & $M$ & \code{DoubleLayer} & $\dsp M\lambda = -\int_{\Gamma}\dny G(\xx,\yy)\lambda(\yy)\;\dd\yy$\\\hline
4 & $N$  & \code{DnSingleLayer}& $\dsp N\rho = \dnx\int_{\Gamma}G(\xx,\yy)\rho(\yy)\;\dd\yy$\\\hline
5 & $D$  & \code{DnDoubleLayer}&$\dsp D\lambda = -\dnx\int_{\Gamma}\dny G(\xx,\yy)\lambda(\yy)\;\dd\yy$\\ \hline
6 & $\hat{L}L$  & \code{PrecondDirichlet}& Single-scattering preconditioned trace of the single-layer operator (see (\ref{??}))\\\hline
7 & $\hat{D}D$  & \code{PrecondNeumann}& Single-scattering preconditioned normal derivative trace of the double-layer operator (see (\ref{??}))\\ \hline
\end{tabular}
\end{center}


\section{Pre-Processing}

The pre-processing in \mudiff consists in defining the right-hand side (or the incident wave) and the geometry (the obstacles). The associated functions are  located respectively in \code{mudiff/PreProcessing/IncidentWave} and \code{mudiff/PreProcessing/Geometry}.

\subsection{Geometry: creating the obstacles}

The obstacles are stored in memory as a row vector \code{a} containing the radii of the disks and a [$2\times\code{N\_scat}$] matrix \code{O} containing the centers of the disks (\code{O(1,p}=$x-$ and \code{O(2,p}=$y-$ coordinates of the center of the $p^{th}$ disk). These two arrays can be created either manually or using some built in functions.

\subsubsection{Manually}

The disks can be created manually by simply creating the two variables \code{O} and \code{a} containing respectively the coordinates of the disks and their radii. For example, for three obstacles placed on $(-1,2)$, $(5,5)$ and $(-15,10)$ with radii $0.1$, $0.5$ and $10$:
\begin{verbatim}
O = [-1, 5, 2 ; -15, 5, 10];
a = [0.1, 0.5, 10];
\end{verbatim}

\subsubsection{Periodic placement}

Two build-in functions are available with the toolbox to create disks periodically, with a rectangular or a triangular lattice, as shown on figure \ref{??}. The two functions must be called as follows, first for the rectangular lattice:
\begin{verbatim}
O = RectangularLattice(bx, by, Nx, Ny);
\end{verbatim}
and second for the triangular lattice:
\begin{verbatim}
O = TriangularLattice(bx,by,Nx,Ny);
\end{verbatim}
where the arguments are:
\begin{itemize}
\item \code{bx}: distance separating two centers in the $x-$ direction (be careful with the radii of the disks to avoid overlapping!).
\item \code{by}: distance separating two row of obstacles in the $y-$ direction.
\item \code{Nx}: number of disks in a row.
\item \code{Ny}: number of rows.
\end{itemize}
For both functions, the vector of radii must be built separately and manually. For a set of unitary disks, the following command does the work:
\begin{verbatim}
a = ones(size(O,2));
\end{verbatim}

\paragraph{Example:} Building a rectangle of $3$ unit disks and $4$ rows. Each disks is separated from a distance of $1.5$ (so the centers from a distance of $3.5$):
\begin{verbatim}
O = RectangularLattice(3.5, 3.5, 3, 4);
a = ones(size(O,2));
\end{verbatim}


\subsubsection{Random placement}

\mudiff provides a function \code{CreateRandomDisks} to randomly place \code{N\_scat} obstacles in a box $[\code{xmin}, \code{xmax}]\times[\code{ymin},\code{ymax}]$ with also a random radius. In its simplest version, the function is called as:
\begin{verbatim}
[O, a] = CreateRandomDisks(xmin, xmax, ymin, ymax, N_scat);
\end{verbatim}
In that case, \code{CreateRandomDisks} builds \code{N\_scat} disk with unit radius in the desired box. The function takes care to not overlap the disks. Note that it is possible that the function does not succeed to place the obstacle (\eg if the user asks for too many obstacles in a small box) and hence a security has been set: only $500$ trials are allowed per disk. 

The function comes along with a large set of optional arguments:
\begin{verbatim}
[O, a] = CreateRandomDisks(xmin, xmax, ymin, ymax, N_scat, 
           amin, amax, dmim, dmax, O_avoid, a_avoid, dmin_avoid, dmax_avoid);
\end{verbatim}
where every additional arguments is optional (but the order must be kept (\code{amin} must be set, then \code{amax}, etc.!) and given by:
\begin{center}
\begin{tabular}{|c |c|c | p{10cm}|}
\hline Variable & Type & Default & Action\\\hline
\code{amin} & scalar  & 1 & Minimal (random) radius of the obstacles allowed \\\hline
\code{amax} & scalar  & 1 & Maximal (random) radius of the obstacles  allowed\\\hline
\code{dmin} & scalar & \code{realmin} & Minimal distance allowed between two obstacle (not between the centers!). Setting $\leq 0$  value will set \code{dmin} to \code{realmin} (\ie ignore it)\\\hline
\code{dmax} & scalar & \code{realmax} & Maximal distance allowed between two obstacle (not between the centers!). The maximal distance is quickly reached! Setting $\leq 0$  value will set \code{dmax} to \code{realmax} (\ie ignore it).\\\hline
\code{O\_avoid} & \code{[2 x N]} & \code{[]} & Center of \code{N} hole(s) where the obstacles must not overlap. Usefull for example for point source location.\\\hline
\code{a\_avoid} & \code{[1 x N]} & \code{[]} & Radii of the \code{N} holes\\\hline
\code{dmin\_avoid} & \code{[1 x N]} & \code{[]} & Minimal distance between an obstacle and a hole\\\hline
\end{tabular}
\end{center}
The ``holes'', represented by the \code{*\_avoid} arguments, are disks where the obstacles must not overlap, for example where a point source is emitting a wave. 

\paragraph{Example 1:} creating \code{N\_scat} random disks with random radii:
\begin{verbatim}
[O, a] = CreateRandomDisks(xmin, xmax, ymin, ymax, N_scat, amin, amax);
\end{verbatim}
\paragraph{Example 2:} building 7 obstacles in the box $[-10,10]\times[-10,10]$ with radii between $0.1$ and $0.5$. The disks must be separated at minimum by a distance of $0.1$ and without maximum value. The command is then:
\begin{verbatim}
[O, a] = CreateRandomDisks(-10, 10, -10, 10, 7, 0.1, 0.5, 0.1, -1);
\end{verbatim}
\paragraph{Example 3:} now imagine that a point source is located on $(2,2)$ and that the obstacles must be separated from the source from at least a distance of $0.3$, then the ``\code{*\_avoid}'' arguments can be used and command can be
\begin{verbatim}
[O, a] = CreateRandomDisks(-10, 10, -10, 10, 7, 0.1, 0.5, 0.1, -1, [2;2], 0.3);
\end{verbatim}
The disk centered on $(2,2)$ with radius $0.3$ will then be avoided. A second option is to set \code{a\_void} to zero and set the minimal distance \code{dmin\_avoid} to $0.3$:
\begin{verbatim}
[O, a] = CreateRandomDisks(-10, 10, -10, 10, 7, 0.1, 0.5, 0.1, -1, [2;2], 0, 0.3);
\end{verbatim}


\begin{remark}
To verify if a disk is well placed, \code{CreateRandomDisks} calls \code{CheckPlacement} function, which can also be useful for a user who is placing the obstacles manually.
\end{remark}

\subsubsection{Removing disks}

The function \code{RemoveDisk} aims to remove some disks of the geometrical configuration, either disk by disk, by row or by column or by radius. This can be useful for example to delete a row of disks. Here is its syntax
\begin{verbatim}
[O,a] = RemoveDisk(O_old, a_old, ...);
\end{verbatim}
where \code{O\_old} and \code{a\_old} are the centers and radii of the current geometry. Without optional argument, the function has no effect. The available arguments are:
\begin{itemize}
\item \code{[O,a] = RemoveDisk(\ldots, 'X', [X1, X2, ..., XN]);}\\
Remove all the disks which center has its $x-$abscissa equal to \code{X1}, \code{X2}, \ldots, or \code{XN}
\item \code{[O,a] = RemoveDisk(\ldots,  'Y', [Y1, Y2, ..., YN]);}\\
Remove all the which center has its $y$-ordinate \code{Y1}, \code{Y2}, ..., or \code{YN}
\item \code{[O,a] = RemoveDisk(\ldots, 'XY', [[X1;Y1], [X2;Y2], \ldots, [XN;YN]]);}\\
Remove all the which center has for coordinates \code{[X1;Y1]}, \code{[X2;Y2]}, \ldots, or \code{[XN;YN]}
\item \code{[O,a] = RemoveDisk(\ldots, 'Radius', [a1, a2, ..., aN]);}\\
Remove all the disk which radius is equal to \code{a1}, \code{a2}, \ldots, or \code{aN}
\item \code{[O,a] = RemoveDisk(\ldots, 'Verbosity', VERBOSITY);}\\
set VERBOSITY to 0 to avoid display message, to 1 to only show results, and to $>1$ to see everything (default).
\item \code{[O,a] = RemoveDisk(\ldots, 'Tol', TOL);}\\
Tolerance used for the conditional statement (default $10^{-10}$).
\end{itemize}

\paragraph{Example 1:} remove every obstacles that are either on the row of $x-$abscissa $1$ or on the column of $y-$ordinate $2.5$:
\begin{verbatim}
[O,a] = RemoveDisk(O\_old, a\_old, 'X', 1, 'Y', 2.5);
\end{verbatim}
\paragraph{Example 2:} remove the obstacles centered on $(2,5)$ and $(3,4)$:
\begin{verbatim}
[O,a] = RemoveDisk(O\_old, a\_old, 'XY', [2, 3; 5, 4]);
\end{verbatim}

\subsection{Incident waves}

\subsubsection{\code{Generalities}}

Two different incident waves are available in the \mudiff toolbox: plane wave and point source wave. It should however be highlighted that the user can build his/her own incident wave. They are all located in \code{PreProcessing/IncidentWave/}.

As explained in section \ref{secEqInt:SecondMembre}, a right-hand side $b$ is decomposed by blocks, each of these representing one obstacle: $b= (b_p)_{p=1,\ldots,\Nscat}$. A different condition can be applied on two different obstacles (\eg Dirichlet on $\Omega_1$ and Neumann on $\Omega_2$) or a different integral equation can be considered on it (\eg EFIE on $\Omega_1$ and MFIE on $\Omega_2$). To handle that, \mudiff builds each block separatly thanks to \code{BlockIncidentWave}, which computes the vector $b_p$. According to the input data, the function will build one of the available right-hand side described on table \ref{table:Uinc}.

On the other hand, the frontal function \code{IncidentWave} computes the whole vector $b$. For every obstacle $p$, it calls \code{BlockIncidentWave} and assembles the whole vector. 

In addition to this, for every incident waves, an interface function is available. They build the whole vector on only one pattern (trace of plane wave, normal derivative of point source wave, \ldots) but are very easy to use. They are located in the \code{interface/} directory and their names are well chosen (see also table \ref{table:Uinc}, column \mudiff name): \code{PlaneWave}, \code{PointSource}, \code{DnPlaneWave},\ldots. Let us highlights that the help of the interface functions contains the mathematical description of the incident wave.

The two main functions, \code{BlockIncidentWave} and \code{IncidentWave}, are now detailed.

\subsubsection{\code{BlockIncidentWave}}

This functions computes the block vector of \textbf{the opposite of} the coefficients of an incident wave, either the trace of the normal derivative trace, on one of the obstacles, in the Fourier bases. Its syntax is
\begin{verbatim}
Bp = BlockIncidentWave(Op, ap, Np, k, TypeOfWave, Param);
\end{verbatim}
where \code{TypeOfWave} is a scalar value specifying the incident wave (see table \ref{table:Uinc}) and \code{Param} is the parameter of the wave: angle of direction, position of a point source, \ldots. The returned value \code{Bp} is a column vector of length $2\code{Np}+1$.
\begin{table}
\begin{tabular}{|c| c |c| p{9cm}| }
\hline Value & \mudiff name & Param & Type\\\hline
1 & \code{PlaneWave} & \code{beta\_inc} & Trace of a plane wave of angle of direction \code{beta\_inc}. A plane wave is defined by $e^{ik(\cos(\beta)x + \sin(\beta)y}$.\\\hline
2 & \code{DnPlaneWave} & \code{beta\_inc} & Normal derivative of a plane wave of angle of direction \code{beta\_inc}.\\\hline
3 & \code{PointSource} & \code{XS} & Trace of the wave emitted by a point source placed on \code{XS}. Such a wave is defined in \mudiff by $i/4\Hz(k\|\xx-\xx_s\|)$.\\\hline
4 & \code{DnPointSource} & \code{XS} & Normal derivative of the trace of the wave emitted by a point source placed on \code{XS}.\\\hline
5 & \code{PlaneWavePrecond} & \code{beta\_inc} & Same as \code{PlaneWave} but multiplied by the inverse diagonal of the single-layer diagonal block operator (see section \ref{} on single scattering preconditioner). \\\hline
6 & \code{DnPlaneWavePrecond} & \code{beta\_inc} & Same as \code{DnPlaneWave} but multiplied by the inverse diagonal of the double-layer diagonal block operator. \\\hline
\end{tabular}
\caption{Available right-hand sides}
\label{table:Uinc}
\end{table}

\subsubsection{\code{IncidentWave}}

\begin{verbatim}
B = IncidentWave(O, a, M_modes, k, TypeOfWave, Param)
\end{verbatim}
The resulting vector \code{B} is of size $\sum_{p=1}^{\Nscat}(2\code{M\_modes}(p)+1)$. The value \code{Param} is the same as for \code{BlockIncidentWave} whereas \code{TypeOfWave} is a vector of size $\Nscat$ where \code{TypeOfWave}(p) is the desired choice for the block $b_p$. In other word, the block $b_p$ will be built by calling \code{BlockIncidentWave(Op, ap, Np, k, TypeOfWave, Param);}. To simplify, if \code{TypeOfWave} is a scalar value, then it is considered as a vector of the same scalar value.

\paragraph{Example1:} building a vector associated to the trace of an incident plane wave of direction \code{beta\_inc} is done thanks to the following command (the ``$1$ argument'' refers to \code{PlaneWave}):
\begin{verbatim}
B = IncidentWave(O, a, M_modes, k,  1, beta_inc);
\end{verbatim}
or using the interface function
\begin{verbatim}
B = PlaneWave(O, a, M_modes, k, beta_inc);
\end{verbatim}
\paragraph{Example 2:} For two obstacles and a point source centered on $(1,2)$, if $b_1$ is the trace of the wave and $b_2$ is the normal derivative trace, then
\begin{verbatim}
B = IncidentWave(O, a, M_modes, k,  [3;4],[1;2]);
\end{verbatim}
In other words, this builds the vector (\code{[3,4]} can be translated as \code{PointSource, DnPointSource}):
$$
b = \left(\begin{array}{c}
-\uinc|_{\Gamma_1}\\
-\dn\uinc|_{\Gamma_2}\\
\end{array}\right),
$$
where $\uinc = \frac{i}{4}\Hz(k\|\xx-\xx_s\|)$, with $\xx_s = [1,2]$.
\begin{remark}
Remember that the resulting vector corresponds to the opposite of the trace or normal derivative trace!
\end{remark}


\section{Integral operators}

Two different type of storage are provided with the \mudiff toolbox: dense and sparse. The dense version store the whole matrix in memory whereas the sparse version uses the special structure of the matrix of an integral operator to store it. The sparse storage in \mudiff and this user guide has nothing to deal with the sparse storage provided in \matlab such as \texttt{sparse} function. The dense storage is easier to use and works pretty well for small scale problems. It also presents the advantage of providing the whole matrix of the integral operator, which can be useful for spectrum analysis for example. On the other hand, for a large number of circular obstacles and/or for large frequency, the memory storage becomes too important and the sparse version must be used. One should be however careful: the sparse matrix-vector product, based on the cross-correlation (\texttt{xcorr} \matlab function), is very sensitive to the number of modes chosen in the truncation of the Fourier series. Indeed, if too many modes are kept, the matrix-vector product show to be unstable. The formula (\ref{??}) seems to provide stability.

To explain how the code works, let us take an example of one of the four boundary integral operator $L,M,N$ or $D$ being discretized as a generic matrix $\Ab = (\Abpq)_{1\leq p,q\leq \Nscat}$. Let us highlight that \mudiff can manage more complexe matrices, where two different blocks are not the discretization of the same operators or can even be a linear combination of operators. Nevertheless, if $\Ap$ is one of the four boundary integral operators, then as highlighted in previous chapter, $\Ab$ has the following structure, for $p,q=1,\ldots,\Nscat$ and $p\neq q$:
\begin{itemize}
\item $\Abpp$ is diagonal.
\item $\Abpq$ is full and can be divided as $\Abpq = \AbpqL\Tbpq\AbpqR$ where $\AbpqL$ and $\AbpqR$ are diagonal and called respectively the left and right part, and $\Tbpq = (\Tbpqmn))$, with $\Tbpqmn = i\pi e^{??}H_0^{(1)}(k\bpq)$, is a Toeplitz matrix.
\end{itemize}
In the sparse version, diagonal submatrices $\Abpp,\AbpqL$ and $\AbpqR$  are stored as a vector of size respectively $2\Np+1$, $2\Np+1$ and $2\Nq+1$, and the Toeplitz matrices $\Tbpq$ are stored as vectors of size $2\Np+2\Nq-1$.

This section is naturally divided in two part, the first being devoted to the dense storage and the second to the sparse version. The assembly, the storage and the usage of the matrices being significantly different.

\subsection{Available integral operators and numbering}
\label{seccode:IntOp}

\mudiff can build the four boundary integral operators $L,M,N$ and $D$ described in the previous chapter, and also the single-scattering version of the EFIE, that is $??$ (Dirichlet) and $??$ (Neumann). As for the incident wave, in \mudiff, a unique number is assigned to every operator.

\begin{center}\begin{tabular}{|c| c| c|c|}
\hline Int. Op. & Number & \mudiff Name & Value for $\xx\in\Gamma$\\\hline
- & 0 & \code{Zero} & Zero operator (null matrix)\\\hline
$I$ & 1 & \code{Identity} & Identity\\\hline
$L$ & 2 & \code{SingleLayer} & $\dsp L\rho(\xx) = \int_{\Gamma} G(\xx,\yy) \rho(\yy)\dd\yy$\\\hline
$M$ & 3 & \code{DoubleLayer} & $\dsp M\lambda(\xx) = -\int_{\Gamma} \dny G(\xx,\yy) \lambda(\yy)\dd\yy$\\\hline
$N$ & 4 & \code{DnSingleLayer} & $\dsp N\rho(\xx) = \dnx\int_{\Gamma} G(\xx,\yy) \rho(\yy)\dd\yy$\\\hline
$D$ & 5 & \code{DnDoubleLayer} & $\dsp D\lambda(\xx) = -\dnx\int_{\Gamma} \dny G(\xx,\yy) \lambda(\yy)\dd\yy$\\\hline
$\hat{L}L$ & 6 & \code{PrecondDirichlet} & Single-Layer preconditioned by its diagonal\\\hline
$\hat{D}D$& 7 & \code{PrecondNeumann} & Dn Double-Layer preconditioned by its diagonal\\\hline
\end{tabular}\end{center}

\subsection{Dense storage}
\subsubsection{Building a block $\Abpq$}

A block is created thanks to \texttt{BlockIntegralOperator} function, which has the following syntax
\begin{verbatim}
	Apq = BlockIntegralOperator(Op, ap, Np, Oq, aq, Nq, k, TypeOfOperator, Weight);
\end{verbatim}
The \code{Weight} argument is optional and set to $1$ by default. The quantity \code{TypeOfOperator} specifies the integral operator to compute, thanks to the numbering of section \ref{seccode:IntOp}. If \code{TypeOfOperator} is a scalar (\eg $=2$) then the resulting matrix \code{Apq} is the submatrix of the associated operator (\eg $\Lbpq$). If \code{TypeOfOperator} is a row (\eg \code{[1,3]}) then the sum of the two operators is done (\eg $\Ibpq+\Mbpq$). Finally the \code{Weight} quantity, of the same size as \code{TypeOfOperator}, is the constant to multiply the block with.

An example being more precise than a huge speak, let us build some blocks:
\begin{itemize}
\item The single-layer block $\Lbpq$:
\begin{verbatim}
Apq = BlockIntegralOperator(Op, ap, Np, Oq, aq, Nq, k, 1);
\end{verbatim}
\item The block $0.5\Ibpq + \Mbpq$, appearing in the MFIE (\ref{??}):
\begin{verbatim}
Apq = BlockIntegralOperator(Op, ap, Np, Oq, aq, Nq, k, [1, 3], [0.5, 1]);
\end{verbatim}
\item The sum of the four integral operator $0.5\Lbpq + 1.5\Mbpq + 2.5\Nbpq + 3.5\Dbpq$:
\begin{verbatim}
Apq = BlockIntegralOperator(Op, ap, Np, Oq, aq, Nq, k, [2, 3, 4, 5], 
[0.5, 1.5, 2.5, 3.5]);
\end{verbatim}
\end{itemize}

\subsubsection{Assemble the matrix $\Ab$}

Now that the construction of a block is well understood, building a matrix is very easy thanks to the frontal function
\begin{verbatim}
A = IntegralOperator(O, a, M_modes, k, TypeOfOperator, Weight);
\end{verbatim}
As for \code{BlockIntegralOperator}, the quantity \code{Weight} is optional and set to $1$ by default. Roughly speaking, \code{IntegralOperator} will loop on every obstacle $p$ and $q$ and launch the following command
\begin{verbatim}
Apq = BlockIntegralOperator(Op, ap, Np, Oq, aq, Nq, k, Tpq, Wpq);
\end{verbatim}
where \code{Tpq} and \code{Wpq} are given by \code{TypeOfOperator} and \code{Weight} such that (\code{Weight} is of the same size of \code{TypeOfOperator} and so \code{Wpq} follows the same rules as \code{Tpq}):
\begin{itemize}
\item If \code{TypeOfOperator} is a scalar then \code{Tpq} = \code{TypeOfOperator}. 
\item If \code{TypeOfOperator} is a row or a column vector then \code{Tpq} is an array given by \code{Tpq} = \code{TypeOfOperator}. 
\item If \code{TypeOfOperator} is a matrix then \code{Tpq} = \code{TypeOfOperator(p,q)}. 
\item If \code{TypeOfOperator} is a $3D-$array then \code{Tpq} is an array and is given by \code{Tpq(:)} = \code{TypeOfOperator(p,q,:)}. 
\end{itemize}

For example, building \ldots 
\begin{itemize}
\item The single-layer potential $L$
\begin{verbatim}
L = IntegralOperator(O, a, M_modes, k, 2);
\end{verbatim}
\item The operator of the MFIE for a Dirichlet boundary condition (\ref{??}), $0.5I + N$:
\begin{verbatim}
A_MFIE = IntegralOperator(O, a, M_modes, k, [1,4], [0.5,1]);
\end{verbatim}
\item The following operator
$$
\left(\begin{array}{c c}
0.5 I_{1,1}+ M_{1,1} & L_{1,2}\\
D_{2,1} & 0.5 I_{2,2}+N_{2,2}
\end{array}\right)
$$
can be done using also the null operator:
\begin{verbatim}
TypeOfOp = zeros(2,2,2); Weight = zeros(2,2,2);
TypeOfOp(1,1, :) = [1, 3]; Weight(1,1, :) = [0.5, 1]; %block A_{1,1}
TypeOfOp(1,2, :) = [2, 0]; Weight(1,2, :) = [1, 0]; %block A_{1,2}
TypeOfOp(2,1, :) = [5, 0]; Weight(2,1, :) = [1, 0]; %block A_{2,1}
TypeOfOp(2,2, :) = [1, 4]; Weight(2,2, :) = [0.5, 1]; %block A_{2,2}
A = IntegralOperator(O, a, M_modes, k, TypeOfOp, Weight);
\end{verbatim}
\end{itemize}

\subsection{Sparse storage}

Storing the matrices in a sparse way lead to a significant reduction in memory storage and a faster matrix-vector product. The linear system must then however be solved using an iterative solver only, as the matrix is no more fully stored. Combining linearly the matrices is still possible but is done during the matrix-vector product, indeed, summing two matrices of two different integral operators is not guaranteed to keep the special structure. If the problem involves (at least) two different integral operators, they must hence be computed separately.

\subsubsection{Storage: generalities}

To explain how the matrix is stored using \mudiff sparse storage, let $\Ab$ be the matrix of one of the four integral operators $L,M,N$ or $D$. The matrix $\Ab$ has the following special structure
\begin{itemize}
\item $\Abpp$ is diagonal
\item $\Abpq$ is full and can be divided as $\Abpq = \AbpqL\Tbpq\AbpqR$ where $\AbpqL$ and $\AbpqR$ are diagonal and called respectively the left and right part, and $\Tbpq = (\Tbpqmn))$, with $\Tbpqmn = i\pi e^{??}H_0^{(1)}(k\bpq)$, is a Toeplitz matrix.
\end{itemize}

Let $\AbL$ and $\AbR$ be two $3D$ arrays such that
$$
\AbL(:,p,q) = \begin{cases}
\diag(\Abpp) & \text{ if }p=q,\\
\AbpqL & \text{ otherwise,}
\end{cases}\qquad
\AbR(:,p,q) = \begin{cases}
0 & \text{ if }p=q,\\
\AbpqR & \text{ otherwise.}
\end{cases}
$$
There is only $\Tbpq$, of size $(2\Np+1) \times (2\Nq+1)$ to be stored sparsely. A Toeplitz matrix has the following structure
$$
\Tbpq = \left(\begin{array}{c c c c c}
t_1 & t_2 & t_3 & \ldots & t_{(2\Nq+1)} \\
t_{(2\Nq+1)+1} & t_{1} & t_{2} & \ldots & t_{(2\Nq+1)-1}\\
t_{(2\Nq+1)+2} & t_{(2\Nq+1)+1} & t_{1} & \ldots & t_{(2\Nq+1)-2}\\
\vdots & \ddots & \ddots& \ddots& \vdots\\
%t_{(2\Nq+1)+(2\Np+1)-2} & t_{(2\Nq+1)+(2\Np+1)-3} & t_{(2\Nq+1)+(2\Np+1)-4} &   \ldots & t_{(2\Np+1)+1}\\
t_{(2\Nq+1)+(2\Np+1)-1} & t_{(2\Nq+1)+(2\Np+1)-2} & t_{(2\Nq+1)+(2\Np+1)-3} &   \ldots  & t_{(2\Nq+1)-(2\Np+1)+1}
\end{array}\right)
$$
Clearly, only the first row and the first column are necessary to build the matrix and hence $\Tbpq$ can be stored as a root vector $\AbpqM$ of size $(2\Np+1)+ (2\Nq+1)-1 = 2\Np +2\Nq+1$ and such that:
$$
\AbpqM = \left(\begin{array}{c}
t_{(2\Nq+1)+(2\Np+1)-1}\\
t_{(2\Nq+1)+(2\Np+1)-2}\\
\vdots\\
t_{(2\Nq+1)+2}\\
t_{(2\Nq+1)+1}\\
t_{1}\\
t_{2}\\
t_{3} \\
\vdots\\
t_{(2\Nq+1), 1}\\
\end{array}\right).
$$
Finally, the $3D$ array $\AbM$ will store every sub-vectors $\AbpqM$:
$$
\AbM(:,p,q) = \begin{cases}
0 & \text{ if }p=q,\\
\AbpqM & \text{ otherwise.}
\end{cases}
$$

The whole matrix $\Ab$ is thus stored in three different part: $\AbL$, $\AbM$ and $\AbR$. In the computer point of view, as a $3D$ array has a fix size in each direction, hence, in Matlab, the sizes of the arrays are given by
\begin{center}
\begin{tabular}{| l | l |}
\hline$\AbL$ & $\dsp \max_p(2\Np+1)$\\[0.2cm]\hline
$\AbM$ & $\dsp \max_{p}\max_{q\neq p}\left[(2\Np+1)+(2\Nq+1)-1\right]$\\[0.2cm]\hline
$\AbR$ & $\dsp \max_p(2\Np+1)$\\[0.2cm]\hline
\end{tabular}\end{center}
With this constraint, the vector $\AbL(:,p,q)$ can be larger than $2\Np+1$ and thus $\AbpqL$ must be extracted: $\AbpqL = \AbL(1:2\Np+1,p)$. The same occurs for $\AbM$ and $\AbR$. 

Finally, these $3D$ arrays are merged into a cell \code{A}, representing the matrix $\Ab$, such that, using the Matlab notations:
$$
\code{A}\{1\} = \AbL,\qquad \code{A}\{2\} = \AbM,\qquad\code{A}\{3\} = \AbR.
$$

\subsubsection{Matrix-vector product}

The matrix vector product between \code{A} and a vector $X$ is divided in different parts. Let us look at $Y=\Ab X$ and more particularly at the $p^{th}$ component
$$
Y_p = \sum_{q} \Abpq X_q.
$$
Using the previous notations, it comes that
$$
Y_p = \AbppL X_p + \sum_{q\neq p} \AbpqL (\AbpqM (\AbpqR X_q)).
$$
As $\AbppL$, $\AbpqL$ and $\AbpqR$ are all diagonal (and stored as a vector), these matrix-vector products are easy to compute. The only difficulty is located in $\AbpqM Z_q$ (where $Z_q=\AbpqR X_q$), but it can be achieved in a fast way. Indeed, the discrete cross correlation product (\code{xcorr}) between $\AbpqM$ and $Z_q$ gives
$$
\widetilde{W}_q = \code{xcorr}(Z_q, \overline{\AbpqM}),
$$
where the over bar denotes a complex conjugation. And the result $W_q$ is then extracted from $\widetilde{W}_q$ by
$$
W_q = \widetilde{W}_q(2\Nq+1:2\Nq+1+2\Np).
$$
The matrix vector product between $\Ab$ and $X$ is then done in a fast way (cross correlation is fast using Fourier).


\subsubsection{Assembly: Matlab functions}

The assembly process is very similar to the dense one, the difference being the prefix \code{Sp}. The block function is then called by
\begin{verbatim}
SpBlockIntegralOperator(Op, ap, Np, Oq, aq, Nq, Nmax, k, TypeOfOperator, Weight);
\end{verbatim}
The major difference here is that \textbf{no linear combination of operators can be done during the assembly process} for the sparse representation. The quantity \code{TypeOfOperator} cannot hence be a vector but only a scalar. On the other hand, the full assembly of a matrix can be done through
\begin{verbatim}
A = SpIntegralOperator(O, a, M_modes, k, TypeOfOperator, Weight);
\end{verbatim}
where \code{TypeOfOperator} can be a scalar or a matrix (not a $3D$ array nor a vector!). If \code{TypeOfOperator} is a matrix, then the block $\Abpq$ is assumed to be of type \code{TypeOfOperator(p,q)}. The linear combination of operators can still be done, but must be specified in the matrix-vector product (see below). Note that a function exists to add the (weighted-)identity to a sparse operator (see below).

Here is an example of the creation of \mudiff sparse matrix of the single-layer operator $L$
\begin{verbatim}
L = SpIntegralOperator(O, a, M_modes, k, 2);
\end{verbatim}

\subsubsection{Assembly: adding the identity}

It is possible to add the identity multiplied by a constant to a sparse operator, thanks to
\begin{verbatim}
A = SpAddIdentity(A, alpha, M_modes);
\end{verbatim}
which simply returns $A = A+\alpha I$.

\subsubsection{Linear combination of operator}

A matrix vector product $Y = \Ab X$ is done thanks to 
\begin{verbatim}
Y = SpMatVec(X, M_modes, ListOfOperators, Weight);
\end{verbatim}
where \code{Weight} is optional. \code{ListOfOperators} is a \textbf{Matlab cell} (not an array!) containing every sparse matrix that the user want to multiply. For example, computing $\Lb X$ is done as follows:
\begin{verbatim}
SpL = SpIntegralOperator(O, a, M_modes, k, 2);
Y = SpMatVec(X, M_modes, SpL);
\end{verbatim}
And computing $Y =(0.5*I + N)X$, where $I$ is the identity (\textbf{Beware the $\{\cdot\}$ !}):
\begin{verbatim}
[SpN{1}, SpN{2}, SpN{3}] = SpDnSingleLayer(O, a, M_modes, k);
[I{1},I{2},I{3}] = SpIdentity(O, a, M_modes);
Y = SpMatVec(X, M_modes, {I,A}, [0.5, 1]);
\end{verbatim}
This could also be done using \code{SpAddIdentity} function:
\begin{verbatim}
[SpN{1}, SpN{2}, SpN{3}] = SpDnSingleLayer(O, a, M_modes, k);
[A{1},A{2},A{3}] = SpAddIdentity(SpN, 0.5, M_modes);
Y = SpMatVec(X, M_modes, A);
\end{verbatim}

\subsubsection{Solving a linear system}

Now that the matrices and the right hand side have been assembled, the sparse linear system can solved iteratively. Using for example the GMRES solver \cite{??}, the syntax to solve the EFIE (\ref{??}) would be
\begin{verbatim}
SpL = SpIntegralOperator(O, a, M_modes, k, 2);
Uinc = PlaneWave(O, a, M_modes, k, beta_inc);
rho = gmres(@(X)SpMatVec(X, M_modes, SpL), Uinc);
\end{verbatim}
Solving the MFIE (\ref{}) can be done as
\begin{verbatim}
[SpN{1}, SpN{2}, SpN{3}] = SpDnSingleLayer(O, a, M_modes, k);
[I{1},I{2},I{3}] = SpIdentity(O, a, M_modes);
DnUinc = DnPlaneWave(O, a, M_modes, k, beta_inc);
lambda = gmres(@(X)SpMatVec(X, M_modes,{I,SpN}, [0.5,1]), DnUinc);
\end{verbatim}
or using the \code{SpAddIdentity} function
\begin{verbatim}
[SpAMFIE{1}, SpAMFIE{2}, SpAMFIE{3}] = SpDnSingleLayer(O, a, M_modes, k);
[SpAMFIE{1}, SpAMFIE{2}, SpAMFIE{3}] = SpAddIdentity(SpAMFIE, 0.5, M_modes);
DnUinc = DnPlaneWave(O, a, M_modes, k, beta_inc);
lambda = gmres(@(X)SpMatVec(X, M_modes, SpAMFIE, ), DnUinc);
\end{verbatim}


\section{Post-Processing}

Now that the system has been solved, the next step is to display the results. The \mudiff toolbox proposes some post-processing features such as computing the far-field (fast) or the near-field (more time consuming) of the wave on a grid (Matlab \code{mesh grid}) or on some points only. In addition, other features are available to draw the disks or the incident field. Both the near- and far-field computations can be done for a linear combination of a single- and double-layer potentials $\Lop\rho + \Mop\lambda$, only one of them (\eg $\Lop\rho$) or with the same density $(\Lop+\Mop)\psi$, with a single command line. Every post-processing functions are located in the \code{PostProcessing/} directory.

\subsubsection{Far field}

The far field of a potential $\sum_{p=1}^{\Nscat}\eta_p\Lop_p\rho_p + \gamma_p\Mop_p\lambda_p$, given by formul\ae{} (\ref{??}) and (\ref{??}), is computed thanks to the \code{FarField} function:
\begin{verbatim}
F = FarField(O, a, M_modes, k, theta, Density, Weight);
\end{verbatim}
where \code{theta} is the vector of receiving angles (in rad.), \code{Density} is either $\rho$, $\lambda$ or both and \code{Weight} is the weights to apply to the $\Nscat$ volumic integral operators. The quantity \code{Weight} is of size either $[1\times2]$ or $[1\times\Nscat]$. To be more precise, the potential is assumed to be of the form
$$
\code{Weight(p, 1)}\Lop\code{Density(:,1)} + \code{Weight(p,2)}\Mop\code{Density(:,2)}.
$$
Note that if \code{Density} is a column vector then \code{Density(:,2)} = \code{Density(:,1)} (the same density is used for both single- and double-layer potentials. In the same way, if \code{Weight} is a $[2\times1]$ vector then \code{Weight}(p,1) = \code{Weight}(1) (this is done automatically). Here is the example of the EFIE for the Dirichlet problem, where the scattered field $u$ reads as $u = \Lop\rho$, its far field is then computed by
\begin{verbatim}
F = FarField(O, a, M_modes, k, theta, rho, [1,0]);
\end{verbatim}
For the Brackage-Werner integral equation for the Dirichlet problem,  the scattered field $u$ reads as $u = (-\eta\Lop-\Mop)\psi$, and its far field is computed by
\begin{verbatim}
F = FarField(O, a, M_modes, k, theta, psi, [-eta,-1]);
\end{verbatim}
If $\rho$ and $\lambda$ are both computed and the user needs to compute $\sum_{p=1}^{\Nscat} p\Lop_p\rho_p - p\Mop_p\lambda_p$, then: 
\begin{verbatim}
F = FarField(O, a, M_modes, k, theta, [rho, lambda], [[1:p].', -[1:p].']);
\end{verbatim}

\subsubsection{Radar Cross Section (RCS)}

The radar cross section of a far field can be computed either from the far field with \code{FarField\_to\_RCS} or directly from the density with \code{RCS}. In \mudiff, the radar cross section $\sigma$ is obtained by ($F$ being the far field)
$$
\sigma = 10\log_{10}(2\pi|F|^2).
$$
The syntax is then simply
\begin{verbatim}
R = FarField_to_RCS(F);
\end{verbatim}
where \code{F} has been computed by the \code{FarField} function. Otherwise, the RSC can be computed directly from the densities by
\begin{verbatim}
R = RCS(O, a, M_modes, k, theta, Density, Weight);
\end{verbatim}
where the arguments are exactly the same as for the far field. In fact, \code{RCS} first calls \code{FarField} and the \code{FarField\_to\_RCS}.

\subsubsection{Near field}

The near field of a potential is given by equations (\ref{??}) and (\ref{??}) outside the obstacles and by (\ref{??}) and (\ref{??}) inside. In the same way, \mudiff separates the outside and the inside computation.


\paragraph{Outside the obstacles}
The assumption on the potentials are exactly the same as for the far field. The user only needs to create a mesh using \eg \code{meshgrid} and launch \code{ExternalPotential}, which syntax is
\begin{verbatim}
U = ExternalPotential(X, Y, O, a, M_modes, k, Density, TypeOfOperator, OPTIONS);
\end{verbatim}
The arguments are exactly the same as for \code{FarField}, except obviously for \code{X} and \code{Y}, which come from the mesh grid, and the options (see below). The resulting matrix \code{U} has $0$ value inside the obstacle. By default, the computation is not done on the boundary of the obstacles. Here is an example of usage for $u=\Lop\rho$:
\begin{verbatim}
XX = [-10:0.1:10];
YY = [-10:0.1:10];
[X,Y] = meshgrid(XX,YY);
U = ExternalPotential(X, Y, O, a M_modes, k, rho, [1,0]);
\end{verbatim}

\paragraph{Inside the obstacles}
Inside the obstacle $\Omega_p$, the only contribution is assumed to be of the form $\Lop_p\rho_p + \Mop_p\lambda_p$ (the other contributions are not computed). In the same way as for the external potential, the computation is done in \mudiff as:
\begin{verbatim}
U = InternalPotential(X, Y, O, a, M_modes, k, Density, TypeOfOperator, OPTIONS);
\end{verbatim}
where \code{U} has zero value outside the obstacles and by default, also on the boundaries.

\paragraph{Common options}

\code{ExternalPotential} and \code{InternalPotential} share the same options which are described here. For the sake of clarity, the examples are shown with only \code{ExternalPotential} even if they work also for \code{InternalPotential}.
\begin{itemize}
\item \code{ExternalPotential(..., 'Verbosity', VERBOSITY} : VERBOSITY is a scalar, which when set to 0, stop displaying message (default = 1)
\item \code{ExternalPotential(..., 'OnBoundary', ONBOUNDARY} : if ONBOUNDARY is set to $1$ then the boundary is also covered (beware of the jump relation\ldots) (default = 0)
\end{itemize}

\subsubsection{Incident wave}

The incident waves can be also computed on a grid using 
\begin{verbatim}
Uinc = IncidentWaveOnGrid(X, Y, k, TypeOfWave, Param);
\end{verbatim}
where \code{Param} is either the angle of direction for a plane wave (scalar) or the location of a point source ($[2\times1]$ vector). The \code{TypeOfWave} is either a \code{char} or a scalar value and follows the same rules as \code{IncidentWave} function from the PreProcessing part (see \S\ref{??}), except for the \code{char} possibility. \code{X} and \code{Y} ares matrices coming from the \code{meshgrid} Matlab function. Below is an example of the computation of a plane wave of angle of direction \code{beta\_inc}:
\begin{verbatim}
Uinc = IncidentWaveOnGrid(X, Y, k, 'PlaneWave', beta_inc);
\end{verbatim}

 
\subsubsection{Geometry}

The \mudiff toolbox also proposes some functions for the post processing of obstacles. 
\paragraph{Drawing the disks:}
\begin{verbatim}
PlotCircles(O, a, fig_index, OPTIONS);
\end{verbatim}
where \code{fig\_index} is the Figure handle and the OPTIONS are
\begin{itemize}
\item \code{PlotCirclesOnFigure(..., 'Color', COLOR)}: apply the \code{COLOR} color to lines (same as the plot function)
\item \code{PlotCirclesOnFigure(..., 'LineWidth', LINEWIDTH)}: set the line width to \code{LINEWIDTH} (same as the plot function)
\item \code{PlotCirclesOnFigure(..., 'zdata', ZDATA)}: set the zdata of the figure to \code{ZDATA} (same as the plot function)
\end{itemize}
Remark that, when drawing disks on a figure containing some values, do not forget to set the zdata to the max value! Examples: 
\begin{verbatim}
figure(1);
surf(X,Y,U);
PlotCirclesOnFigure(O, a, 1, 'zdata', max(max(U)));
\end{verbatim}

\paragraph{Getting a mask matrix}, that is a matrix $S$ such that, is $X$ and $Y$ are obtained by \code{meshgrid}:
$$
S(i,j) = \begin{cases}
0 & \text{ if } (X(i,j),Y(i,j)) \text{ is outside the obstacles,}\\
p & \text{ if } (X(i,j),Y(i,j)) \in\Omega_p,\\
p+0.5 & \text{ if } (X(i,j),Y(i,j)) \in\Gamma_p.\\
\end{cases}
$$
This kind of matrix is handy when plotting the potentials and is actually used by \code{ExternalPotential} and \code{InternalPotential}. The function \code{MaskMatrix} which provides the matrix $M$ has the following syntax
\begin{verbatim}
S = MaskMatrixObstacles(X, Y, O, a);
\end{verbatim}

\paragraph{Extract the boundary points.} In the same way as the \code{MaskMatrixObstacles} function, \code{BoundaryOfObstacles} leads to a matrix $G$ where
$$
G(i,j) = \begin{cases}
0 & \text{ if } (X(i,j),Y(i,j)) \text{ is outside the obstacles,}\\
0 & \text{ if } (X(i,j),Y(i,j)) \in\Omega_p,\\
p & \text{ if } (X(i,j),Y(i,j)) \in\Gamma_p.\\
\end{cases}
$$
Similarly, $G$ is computed by
\begin{verbatim}
G = BoundaryOfObstacles(X, Y, O, a);
\end{verbatim}

\section{Full Examples}

Some examples are available in the \code{Examples} directory and especially in \code{Examples/Benchmark}, where each files is independent and solve a different problem (Dirichlet, Neumann or Penetrable). They should also be launched as a tested, to verify that \mudiff is correctly installed and working properly.

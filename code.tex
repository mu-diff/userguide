\section{Generalities}
The authors try to keep the notations between the mathematical background and the \matlab toolbox. In particular, lots of arguments are the same in the different functions and they are here presented once for all. A manual of every function is moreover provided by simply typing in the \matlab command window 
\begin{verbatim}
help name_of_the_function
\end{verbatim}
In all what follows, and if nothing is specified, then the following arguments refer to the below ones. The indices $p$ and $q$ vary from $1$ to $\Nscat$ where $\Nscat$ is the number of obstacles.

\paragraph{Geometry:}

\begin{center}
%\rowcolors{1}{white}{gray}
\begin{tabular}{|c |c | p{10cm}|}
\hline Name & Size or Type & Content\\[0.2cm]\hline\hline
\code{N\_scat} & $[1\times 1]$ & Number of obstacles $\Nscat$.\\\hline
\code{O} & $[2\times \Nscat]$ & Matrix of the centers of the disks such that \code{O(1,p)} is the x-coordinate of the $p^{th}$ obstacle.\\\hline
\code{Op} & $[2\times 1]$ & Coordinate of the $p^{th}$ scatterer.\\\hline
\code{Oq} & $[2\times 1]$ & Coordinate of the $q^{th}$ scatterer.\\\hline
\code{a} & $[1\times \Nscat]$ & Vector of the radii of the disks such that \code{a(p)} is the radius of the $p^{th}$ scatterer.\\\hline
\code{ap} & $[1\times 1]$ & Radius of the $p^{th}$ scatterer.\\\hline
\code{aq} & $[1\times 1]$ & Radius of the $q^{th}$ scatterer.\\\hline
\end{tabular}
\end{center}

\paragraph{Parameters (wavenumbers, incident waves, fourier series,\ldots):}
\begin{center}
\begin{tabular}{|c |c | p{10cm}|}
\hline Name & Size or Type & Content\\[0.2cm]\hline\hline
\code{beta\_inc} & $[1\times 1]$ & Angle of direction of a plane wave $e^{ik (\cos(\beta)x + \sin(\beta)y)}$.\\\hline
\code{XS} & $[2\times 1]$ & Center $(x_s,y_s)$ of a point source: $x_s=$\code{XS(1)} and $y_s=$\code{XS(2)}. A point source wave is then given by $i/4\Hz(k\|\xx-\xx_s\|)$, with $\xx=(x,y)$ and $\xx_s=(x_s,y_s)$ and $\Hz$ the zeroth order Hankel function of first kind.\\\hline
\code{k} & $[1\times 1]$ & Wavenumber $k$ in the vacuum.\\\hline
\code{k\_int} & $[1\times \Nscat]$ & Wavenumber in the obstacles: $\kintp=$\code{k\_int(p)}. If \code{k\_int} is a scalar then $\kintp$ = \code{k\_int} for all $p$.\\\hline
\code{M\_modes} & $[1\times \Nscat]$ & Vector of index of truncation of the Fourier series, \ie \code{M\_modes(p)}=$\Np$\\\hline
\code{Np} & $[1\times 1]$ & Corresponds to $\Np$, the truncation index in the Fourier serie.\\\hline
\code{Nq} & $[1\times 1]$ & Corresponds to $\Nq$, the truncation index in the Fourier serie.\\\hline
\end{tabular}
\end{center}

\paragraph{Incident wave:}
\begin{center}
\begin{tabular}{|c |c | p{10cm}|}
\hline Name & Size or Type & Content\\[0.2cm]\hline\hline
\code{PlaneWave} & $[1\times 1]$ & Wavenumber in the vacuum.\\\hline
\end{tabular}
\end{center}

\paragraph{Integral operators:} they are indexed and named by the following table:
\begin{center}
\begin{tabular}{|c |c | c | p{9cm}|}
\hline Index & Letter & Operator & \mudiff abreviation \\\hline\hline
0 & - & - & Null operator \\
1 & $I$ & \code{Identity} & Identity\\
2 & $L$ & \code{SingleLayer} & Trace of the single-layer\\
3 & $M$ & \code{DoubleLayer} & Trace of the double-layer\\
4 & $N$  & \code{DnSingleLayer}& Normal derivative of the single-Layer\\
5 & $D$  & \code{DnDoubleLayer}&Normal derivative of the double-Layer\\ 
6 & $\hat{L}$  & \code{PrecondDirichlet}& Single-scattering preconditioned trace of the single-layer operator\\
7 & $\hat{D}$  & \code{PrecondNeumann}& Single-scattering preconditioned normal derivative trace of the double-layer operator\\ \hline
\end{tabular}
\end{center}


\section{Pre-Processing}

The pre-processing functions are located in the \code{PreProcessing} folder, which is divided in two parts: the construction of the obstacles in \code{Geometry}, and the computation of the right-hand side, \ie the incident waves on the obstacles, in \code{IncidentWave}.

\subsection{Creating Obstacles}

\subsubsection{Manual placement}
The disks can be created manually by simply creating the two variables \code{O} and \code{a} containing respectively the coordinates of the disks and their radii. For example, for three obstacles placed on $(-1,2)$, $(5,5)$ and $(-15,10)$ with radii $0.1$, $0.5$ and $10$:
\begin{verbatim}
O = [-1, 5, 2 ; -15, 5, 10];
a = [0.1, 0.5, 10];
\end{verbatim}

\subsubsection{Periodic placement}

Two build-in functions are available with the toolbox to create disks periodically, with a rectangular or a triangular lattice, as shown on figure \ref{??}. The two functions are called as follows, for the rectangular lattice:
\begin{verbatim}
O = RectangularLattice(bx, by, Nx, Ny);
\end{verbatim}
and for the triangular lattice:
\begin{verbatim}
O = TriangularLattice(bx,by,Nx,Ny);
\end{verbatim}
where :
\begin{itemize}
\item \code{bx} and \code{by} are the distance separating two centers in the $x$ coordinate and \code{by} the distance between two rows in the $y$-direction. The two other parameter 
\item \code{Nx}: number of disks in a row
\item \code{Ny}: number of rows
\end{itemize}
For both functions, the vector of radii must be built separately. If the disks are unitary then the following command can be used
\begin{verbatim}
a = ones(size(O,2));
\end{verbatim}


\subsubsection{Random placement}

Finally, to place randomly obstacles in a box $[\code{xmin}, \code{xmax}]\times[\code{ymin},\code{ymax}]$ with also a random radius, a function \code{CreateRandomDisks} is very helpful. In its simplest version, the function is called as:
\begin{verbatim}
[O, a] = CreateRandomDisks(xmin, xmax, ymin, ymax, N_scat);
\end{verbatim}
The function will then create \code{N\_scat} disk with unit radius in the desired box. This is however probably too simple and the function can be called in a more complex form:
\begin{verbatim}
[O, a] = CreateRandomDisks(xmin, xmax, ymin, ymax, N_scat, 
           amin, amax, dmim, dmax, O_avoid, a_avoid, dmin_avoid, dmax_avoid);
\end{verbatim}
where
\begin{center}
\begin{tabular}{|c |c|c | p{10cm}|}
\hline Variable & Type & Default & Action\\\hline
\code{amin} & scalar  & 1 & Minimal (random) radius of the obstacles allowed \\\hline
\code{amax} & scalar  & 1 & Maximal (random) radius of the obstacles  allowed\\\hline
\code{dmin} & scalar & \code{realmin} & Minimal distance allowed between two obstacle (not between the centers!). Setting $\leq 0$  value will set \code{dmin} to \code{realmin} (\ie ignore it)\\\hline
\code{dmax} & scalar & \code{realmax} & Maximal distance allowed between two obstacle (not between the centers!). The maximal distance is quickly reached! Setting $\leq 0$  value will set \code{dmax} to \code{realmax} (\ie ignore it).\\\hline
\code{O\_avoid} & \code{[2 x N]} & \code{[]} & Center of \code{N} hole(s) where the obstacles must not overlap. Usefull for example for point source location.\\\hline
\code{a\_avoid} & \code{[1 x N]} & \code{[]} & Radii of the \code{N} holes\\\hline
\code{dmin\_avoid} & \code{[1 x N]} & \code{[]} & Minimal distance between an obstacle and a hole\\\hline
\end{tabular}
\end{center}
These optional arguments are not mandatory in the function call. For example:
\begin{verbatim}
[O, a] = CreateRandomDisks(xmin, xmax, ymin, ymax, N_scat, amin, amax);
\end{verbatim}
will create random disks with random radii without taking into account the distances between the disks (except obviously the overlapping).

For example, building 7 obstacles in the box $[-10,10]\times[-10,10]$ with radii between $0.1$ and $0.5$. The disks must be separated at minimum by a distance of $0.1$ and without maximum value. The command is then:
\begin{verbatim}
[O, a] = CreateRandomDisks(-10, 10, -10, 10, 7, 0.1, 0.5, 0.1, -1);
\end{verbatim}
Now imagine that a point source is located on $(2,2)$ and that the obstacles must be separated from the source from at least $0.3$, then the ``\code{*\_avoid}'' arguments can be used and command can be
\begin{verbatim}
[O, a] = CreateRandomDisks(-10, 10, -10, 10, 7, 0.1, 0.5, 0.1, -1, [2;2], 0.3);
\end{verbatim}
the disk centered on $(2,2)$ with radius $0.3$ will then be avoided. A second option is to set \code{a\_void} to zero and set the minimal distance \code{dmin\_avoid} to $0.3$:
\begin{verbatim}
[O, a] = CreateRandomDisks(-10, 10, -10, 10, 7, 0.1, 0.5, 0.1, -1, [2;2], 0, 0.3);
\end{verbatim}


\begin{remark}
To verify if a disk is well placed, \code{CreateRandomDisks} calls \code{CheckPlacement} function, which can also be useful for a user placing obstacles.
\end{remark}

\subsubsection{Removing disks}

The function \code{RemoveDisk} aims to remove some disks of the geometrical configuration, either disk by disk, by row or by column or by radius. Here is its syntax
\begin{verbatim}
[O,a] = RemoveDisk(O_old, a_old, ...);
\end{verbatim}
where \code{O\_old} and \code{a\_old} are the centers and radii of the current geometry. Without optional argument, the function will return \code{[O\_old, a\_old]} and the available arguments are:
\begin{itemize}
\item \code{[O,a] = RemoveDisk(..., 'X', [X1, X2, ..., XN]);}\\
Remove all the points with X abscissa X1, X2, ..., or XN
\item \code{[O,a] = RemoveDisk(...,  'Y', [Y1, Y2, ..., YN]);}\\
Remove all the points with Y ordinate Y1, Y2, ..., or YN
\item \code{[O,a] = RemoveDisk(..., 'XY', [[X1;Y1], [X2;Y2], ..., [XN;YN]]);}\\
Remove all the points [X1;Y1], [X2;Y2], ..., and [XN;YN]
\item \code{[O,a] = RemoveDisk(..., 'Radius', [a1, a2, ..., aN]);}\\
Remove all the disk with radius a1, a2, ..., or aN
\item \code{[O,a] = RemoveDisk(..., 'Verbosity', VERBOSITY);}\\
set VERBOSITY to 0 to avoid display message, to 1 to only show results, and to $>1$ to see everything (default).
\end{itemize}

For example, to remove every obstacle on the row of $x-$abscissa $1$ and $y-$ordinate $2.5$:
\begin{verbatim}
[O,a] = RemoveDisk(O\_old, a\_old, 'X', 1, 'Y', 2.5);
\end{verbatim}
Or, to remove the obstacles centered on $(2,5)$ and (3,4):
\begin{verbatim}
[O,a] = RemoveDisk(O\_old, a\_old, 'XY', [2,3;5,4]);
\end{verbatim}

\subsection{Incident waves}

Two different incident waves, plane wave and point source wave, are available in the \mudiff toolbox, but it should be highlighted that the user can build his/her own incident wave. A right-hand side $b$ is decomposed by blocks, each of these representing one obstacle: $b= (b_p)_{p=1,\ldots,\Nscat}$. As a different condition can be applied on an obstacle or a different integral equation can be considered on it, each block can be specified separately. Depending on the type of desired right-hand side, the block function \code{BlockIncidentWave} will compute the vector $b_p$. The frontal function \code{IncidentWave}, which compute the whole vector $b$, consists on calling  \code{BlockIncidentWave} for each obstacle and assembling the vector. Interfaced functions are available to compute directly some incident wave, such as \code{PlaneWave}, \code{PointSource} or \code{DnPlaneWave} and \code{DnPointSource}. They call \code{IncidentWave} with the right argument. There is no need here to described these functions, however their help is helpful and contains the mathematical description of the incident wave.

\subsubsection{\code{BlockIncidentWave}}

This functions computes the block vector of \textbf{the opposite of} the coefficients of an incident wave, either the trace of the normal derivative trace, on one of the obstacles, in the Fourier bases. Its syntax is
\begin{verbatim}
Bp = BlockIncidentWave(Op, ap, Np, k, TypeOfWave, Param);
\end{verbatim}
where \code{TypeOfWave} is a scalar value specifying the incident wave (see below) and \code{Param} is the parameter of the wave, that is the angle of direction or the position of a point source. The returned value \code{Bp} is a column vector of length 2\code{Np}+1. Below is listed the possible value of \code{TypeOfWave}, the interface function name, the associated parameter and the resulting wave:
\begin{center}
\begin{tabular}{|c| c |c| p{9cm}| }
\hline Value & \mudiff name & Param & Type\\\hline
1 & \code{PlaneWave} & \code{beta\_inc} & Trace of a plane wave of angle of direction \code{beta\_inc}. A plane wave is defined by $e^{ik(\cos(\beta)x + \sin(\beta)y}$.\\\hline
2 & \code{DnPlaneWave} & \code{beta\_inc} & Normal derivative of a plane wave of angle of direction \code{beta\_inc}.\\\hline
3 & \code{PointSource} & \code{XS} & Trace of the wave emitted by a point source placed on \code{XS}. Such a wave is defined in \mudiff by $i/4\Hz(k\|\xx-\xx_s\|)$.\\\hline
4 & \code{DnPointSource} & \code{XS} & Normal derivative of the trace of the wave emitted by a point source placed on \code{XS}.\\\hline
5 & \code{PlaneWavePrecond} & \code{beta\_inc} & Same as \code{PlaneWave} but multiplied by the inverse diagonal of the single-layer diagonal block operator (see section \ref{} on single scattering preconditioner). \\\hline
6 & \code{DnPlaneWavePrecond} & \code{beta\_inc} & Same as \code{DnPlaneWave} but multiplied by the inverse diagonal of the double-layer diagonal block operator. \\\hline
\end{tabular}\end{center}

\subsubsection{\code{IncidentWave}}

\begin{verbatim}
B = IncidentWave(O, a, M_modes, k, TypeOfWave, Param)
\end{verbatim}
The resulting vector \code{B} is of size $\sum_{p=1}^{\Nscat}(2\code{M\_modes}(p)+1)$. The value \code{Param} is the same as for \code{BlockIncidentWave} whereas \code{TypeOfWave} is a vector of size $\Nscat$ where \code{TypeOfWave}(p) is the desired choice for the block $b_p$. In other word, the block $b_p$ will be built by calling \code{BlockIncidentWave(Op, ap, Np, k, TypeOfWave, Param);}. To simplify, if \code{TypeOfWave} is a scalar value, then it is considered as a vector of the same scalar value.

For example, building a vector associated to the trace of an incident plane wave of direction \code{beta\_inc} is done thanks to the following command:
\begin{verbatim}
B = IncidentWave(O, a, M_modes, k,  1, beta\_inc);
\end{verbatim}
For two obstacles and a point source centered on $(1,2)$, if $b_1$ is the trace of the wave and $b_2$ is the normal derivative trace, then
\begin{verbatim}
B = IncidentWave(O, a, M_modes, k,  [3;4],[1;2]);
\end{verbatim}

\begin{remark}
Remember that the resulting vector corresponds to the opposite of the trace or normal derivative trace!
\end{remark}


\section{Integral operators}

Two different type of storage are provided with the \mudiff toolbox: dense and sparse. The dense version store the whole matrix in memory whereas the sparse version uses the special structure of the matrix of an integral operator to store it. The sparse storage in \mudiff and this user guide has nothing to deal with the sparse storage provided in \matlab such as \texttt{sparse} function. The dense storage is easier to use and works pretty well for small scale problems. It also presents the advantage of providing the whole matrix of the integral operator, which can be useful for spectrum analysis for example. On the other hand, for a large number of circular obstacles and/or for large frequency, the memory storage becomes too important and the sparse version must be used. One should be however careful: the sparse matrix-vector product, based on the cross-correlation (\texttt{xcorr} \matlab function), is very sensitive to the number of modes chosen in the truncation of the Fourier series. Indeed, if too many modes are kept, the matrix-vector product show to be unstable. The formula (\ref{??}) seems to provide stability.

For both dense and sparse case, let $\Ab$ be a generic matrix representing the matrix of one of the four boundary integral operator, $\Lb,\Mb,\Nb$ and $\Db$. As highlighted in previous chapter, $\Ab$ has the following structure, for $p,q=1,\ldots,\Nscat$ and $p\neq q$:
\begin{itemize}
\item $\Abpp$ is diagonal.
\item $\Abpq$ is full and can be divided as $\Abpq = \AbpqL\Tbpq\AbpqR$ where $\AbpqL$ and $\AbpqR$ are diagonal and called respectively the left and right part, and $\Tbpq = (\Tbpqmn))$, with $\Tbpqmn = i\pi e^{??}H_0^{(1)}(k\bpq)$, is a Toeplitz matrix.
\end{itemize}
In the sparse version, diagonal submatrices $\Abpp,\AbpqL$ and $\AbpqR$  are stored as a vector of size respectively $2\Np+1$, $2\Np+1$ and $2\Nq+1$, and the Toeplitz matrices $\Tbpq$ are stored as vectors of size $2\Np+2\Nq-1$.

This section is naturally divided in two part, the first being devoted to the dense storage and the second to the sparse version.

\subsection{Available integral operators}

The integral operators are numbered as follows
\begin{enumerate}
\item Null operator
\end{enumerate}


\subsection{Dense storage}
\subsubsection{Block structures}

A matrix $\Ab$ is created by blocks using \texttt{BlockIntegralOperator} function, which has the following syntax
\begin{verbatim}
	Apq = BlockIntegralOperator(Op, ap, Np, Oq, aq, Nq, k, TypeOfOperator)
\end{verbatim}
where:
\begin{itemize}
\item \texttt{Op}(resp. \texttt{Oq}): \texttt{2$\times$1}, vector containing the centers of the disk such that \texttt{Op(1,p)}$=x_{\OOp}$ and \texttt{Op(2,p)}$=y_{\OOp}$ (resp. \texttt{Oq(1)}$=x_{\OOq}$ and \texttt{Oq(2)}$=y_{\OOq}$)
\item \texttt{ap}(resp. \texttt{aq}): \texttt{1$\times$1}, Radius of the disks $\OOp$ (resp. $\OOq$)
\item \texttt{Np} (resp. \texttt{Nq}): \texttt{1$\times$1}, Index of truncation $\Np$ (resp. $\Nq$)
\item \texttt{k}: \texttt{1$\times$1}, Wavenumber in the vacuum
\item \texttt{TypeOfOperator}: \texttt{Variable size}, Type of integral operator to be computed.
\end{itemize}

\subsubsection{Full matrix}

\subsection{Sparse storage}
\subsubsection{Block structures}
\subsubsection{Full matrix}

\section{Post-Processing}
\subsubsection{Near field}
\subsubsection{Far field and Radar Cross Section (RCS)}
\subsubsection{Plot and display}


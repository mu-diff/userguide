\section{Generalities}
The authors try to keep the notations between the mathematical background and the \matlab toolbox. In particular, lots of arguments are the same in the different functions and they are here presented once for all. A manual of every function is moreover provided by simply typing in the \matlab command window 
\begin{verbatim}
help name_of_the_function
\end{verbatim}
In all what follows, and if nothing is specified, then the following arguments refer to the below one. The indices $p$ and $q$ vary from $1$ to $\Nscat$ where $\Nscat$ is the number of obstacles.

\begin{center}
%\rowcolors{1}{white}{gray}
\begin{tabular}{|c |c | p{10cm}|}
\hline Name & Size or Type & Content\\[0.2cm]\hline\hline
\code{N\_scat} & $[1\times 1]$ & Number of obstacles $\Nscat$.\\\hline
\code{O} & $[2\times \Nscat]$ & Matrix of the centers of the disks such that \code{O(1,p)} is the x-coordinate of the $p^{th}$ obstacle.\\\hline
\code{Op} & $[2\times 1]$ & Coordinate of the $p^{th}$ scatterer.\\\hline
\code{Oq} & $[2\times 1]$ & Coordinate of the $q^{th}$ scatterer.\\\hline
\code{a} & $[1\times \Nscat]$ & Vector of the radii of the disks such that \code{a(p)} is the radius of the $p^{th}$ scatterer.\\\hline
\code{ap} & $[1\times 1]$ & Radius of the $p^{th}$ scatterer.\\\hline
\code{aq} & $[1\times 1]$ & Radius of the $q^{th}$ scatterer.\\\hline
\code{M\_modes} & $[1\times \Nscat]$ & Vector of index of truncation of the Fourier series, \ie \code{M\_modes(p)}=$\Np$\\\hline
\code{Np} & $[1\times 1]$ & Corresponds to $\Np$.\\\hline
\code{Nq} & $[1\times 1]$ & Corresponds to $\Nq$.\\\hline
\end{tabular}
\end{center}
On the parameters
\begin{center}
\begin{tabular}{|c |c | p{10cm}|}
\hline Name & Size or Type & Content\\[0.2cm]\hline\hline
\code{k} & $[1\times 1]$ & Wavenumber in the vacuum.\\\hline
\code{k\_int} & $[1\times \Nscat]$ & Wavenumber in the obstacles: \code{k\_int(p)} being the one in obstacle $p$.\\\hline
\end{tabular}
\end{center}

The integral operators are indexed by the following table:
\begin{center}
\begin{tabular}{|c |c | c | p{9cm}|}
\hline Index & Letter & Operator & \mudiff abreviation \\\hline\hline
0 & - & - & Null operator \\
1 & $I$ & \code{Identity} & Identity\\
2 & $L$ & \code{SingleLayer} & Trace of the single-layer\\
3 & $M$ & \code{DoubleLayer} & Trace of the double-layer\\
4 & $N$  & \code{DnSingleLayer}& Normal derivative of the single-Layer\\
5 & $D$  & \code{DnDoubleLayer}&Normal derivative of the double-Layer\\ 
6 & $\hat{L}$  & \code{PrecondDirichlet}& Single-scattering preconditioned trace of the single-layer operator\\
7 & $\hat{D}$  & \code{PrecondNeumann}& Single-scattering preconditioned normal derivative trace of the double-layer operator\\ \hline
\end{tabular}
\end{center}


\section{Pre-Processing}

The pre-processing functions are located in the \code{PreProcessing} folder, which is divided in two parts: the construction of the obstacles in \code{Geometry}, and the computation of the right-hand side, \ie the incident waves on the obstacles, in \code{IncidentWave}.

\subsection{Creating Obstacles}

\subsubsection{Manual placement}
The disks can be created manually by simply creating the two variables \code{O} and \code{a} containing respectively the coordinates of the disks and their radii. For example, for three obstacles placed on $(-1,2)$, $(5,5)$ and $(-15,10)$ with radii $0.1$, $0.5$ and $10$:
\begin{verbatim}
O = [-1, 5, 2 ; -15, 5, 10];
a = [0.1, 0.5, 10];
\end{verbatim}

\subsubsection{Periodic placement}

Two build-in functions are available with the toolbox to create disks periodically, with a rectangular or a triangular lattice, as shown on figure \ref{??}. The two functions are called as follows, for the rectangular lattice:
\begin{verbatim}
O=RectangularLattice(bx, by, Nx, Ny);
\end{verbatim}
and for the triangular lattice:
\begin{verbatim}
O = TriangularLattice(bx,by,Nx,Ny);
\end{verbatim}
where \code{bx} and \code{by} are the distance separating two centers in the $x$ coordinate and \code{by} the distance between two rows in the $y$-direction. The two other parameter 
\code{Nx} and \code{Ny} are the number of disks in the $x$direction and the number of rows of disks. For both functions, the vector of radii must be built separately. If the disks are unitary then the following command can be used
\begin{verbatim}
a = ones(size(O,2));
\end{verbatim}


\subsubsection{Random placement}

Finally, to place randomly obstacles in a box $[\code{xmin}, \code{xmax}]\times[\code{ymin},\code{ymax}]$ with also a random radius, a function \code{CreateRandomDisks} is very helpful. In its simplest version, the function is called as:
\begin{verbatim}
[O, a] = CreateRandomDisks(xmin, xmax, ymin, ymax, N_scat)
\end{verbatim}
The function will then create \code{N\_scat} disks in the box with random radii. This is however probably too simple and the function can be called in a more complex form:
\begin{verbatim}
[O, a] = CreateRandomDisks(xmin, xmax, ymin, ymax, N_scat, 
           amin, amax, dmim, dmax, O_avoid, a_avoid, dmin_avoid, dmax_avoid)
\end{verbatim}
where
\begin{itemize}
\item \code{amin} and \code{amax} are scalar values and respectively the minimal and the maximal radius
\item \code{dmin} and \code{dmax} are scalar values and respectively the minimal and the maximal distance allowed between two disks (not between the centers!). A special care must be given to \code{dmax}: the verification is done between every disks and hence, the maximal distance is quickly reach! Setting $0$ or negative value will make \code{CreateRandomDisks} ignores these options.
\item \code{O\_avoid, a\_avoid, dmin\_avoid} and \code{dmax\_avoid}: the arguments corresponds to ``holes'' in the box where the obstacles must not overlap. The notations are the same as for the circular obstacles and have the same size and role as respectively \code{O,a,dmin} and \code{dmax}.
\end{itemize}
For example, building 7 obstacles in the box $[-10,10]\times[-10,10]$ with radii between $0.1$ and $0.5$. The disks must be separated at minimum by a distance of $0.1$ and without maximum value. The command is then:
\begin{verbatim}
[O, a] = CreateRandomDisks(-10, 10, -10, 10, 7, 0.1, 0.5, 0.1, -1);
\end{verbatim}
Now imagine that a point source is located on $(2,2)$ and that the obstacles must be separated from the source from at least $0.3$, then the ``\code{*\_avoid}'' arguments can be used and command can be
\begin{verbatim}
[O, a] = CreateRandomDisks(-10, 10, -10, 10, 7, 0.1, 0.5, 0.1, -1, [2;2], 0.3);
\end{verbatim}
or by using the minimal distance \code{dmin\_avoid} and setting \code{a\_avoid}:
\begin{verbatim}
[O, a] = CreateRandomDisks(-10, 10, -10, 10, 7, 0.1, 0.5, 0.1, -1, [2;2], 0, 0.3);
\end{verbatim}

\begin{remark}
To verify if a disk is well placed, \code{CreateRandomDisks} calls \code{CheckPlacement} function, which can also be useful for a user placing obstacles.
\end{remark}

\subsection{Incident waves}

\section{Integral operators}

Two different type of storage are provided with the \mudiff toolbox: dense and sparse. The dense version store the whole matrix in memory whereas the sparse version uses the special structure of the matrix of an integral operator to store it. The sparse storage in \mudiff and this user guide has nothing to deal with the sparse storage provided in \matlab such as \texttt{sparse} function. The dense storage is easier to use and works pretty well for small scale problems. It also presents the advantage of providing the whole matrix of the integral operator, which can be useful for spectrum analysis for example. On the other hand, for a large number of circular obstacles and/or for large frequency, the memory storage becomes too important and the sparse version must be used. One should be however careful: the sparse matrix-vector product, based on the cross-correlation (\texttt{xcorr} \matlab function), is very sensitive to the number of modes chosen in the truncation of the Fourier series. Indeed, if too many modes are kept, the matrix-vector product show to be unstable. The formula (\ref{??}) seems to provide stability.

For both dense and sparse case, let $\Ab$ be a generic matrix representing the matrix of one of the four boundary integral operator, $\Lb,\Mb,\Nb$ and $\Db$. As highlighted in previous chapter, $\Ab$ has the following structure, for $p,q=1,\ldots,\Nscat$ and $p\neq q$:
\begin{itemize}
\item $\Abpp$ is diagonal.
\item $\Abpq$ is full and can be divided as $\Abpq = \AbpqL\Tbpq\AbpqR$ where $\AbpqL$ and $\AbpqR$ are diagonal and called respectively the left and right part, and $\Tbpq = (\Tbpqmn))$, with $\Tbpqmn = i\pi e^{??}H_0^{(1)}(k\bpq)$, is a Toeplitz matrix.
\end{itemize}
In the sparse version, diagonal submatrices $\Abpp,\AbpqL$ and $\AbpqR$  are stored as a vector of size respectively $2\Np+1$, $2\Np+1$ and $2\Nq+1$, and the Toeplitz matrices $\Tbpq$ are stored as vectors of size $2\Np+2\Nq-1$.

This section is naturally divided in two part, the first being devoted to the dense storage and the second to the sparse version.

\subsection{Available integral operators}

The integral operators are numbered as follows
\begin{enumerate}
\item Null operator
\end{enumerate}


\subsection{Dense storage}
\subsubsection{Block structures}

A matrix $\Ab$ is created by blocks using \texttt{BlockIntegralOperator} function, which has the following syntax
\begin{verbatim}
	Apq = BlockIntegralOperator(Op, ap, Np, Oq, aq, Nq, k, TypeOfOperator)
\end{verbatim}
where:
\begin{itemize}
\item \texttt{Op}(resp. \texttt{Oq}): \texttt{2$\times$1}, vector containing the centers of the disk such that \texttt{Op(1,p)}$=x_{\OOp}$ and \texttt{Op(2,p)}$=y_{\OOp}$ (resp. \texttt{Oq(1)}$=x_{\OOq}$ and \texttt{Oq(2)}$=y_{\OOq}$)
\item \texttt{ap}(resp. \texttt{aq}): \texttt{1$\times$1}, Radius of the disks $\OOp$ (resp. $\OOq$)
\item \texttt{Np} (resp. \texttt{Nq}): \texttt{1$\times$1}, Index of truncation $\Np$ (resp. $\Nq$)
\item \texttt{k}: \texttt{1$\times$1}, Wavenumber in the vacuum
\item \texttt{TypeOfOperator}: \texttt{Variable size}, Type of integral operator to be computed.
\end{itemize}

\subsubsection{Full matrix}

\subsection{Sparse storage}
\subsubsection{Block structures}
\subsubsection{Full matrix}

\section{Post-Processing}
\subsubsection{Near field}
\subsubsection{Far field and Radar Cross Section (RCS)}
\subsubsection{Plot and display}

